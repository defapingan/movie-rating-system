// chart.js@3.9.1 downloaded from https://ga.jspm.io/npm:chart.js@3.9.1/dist/chart.mjs

import{r as t,c as e,a as s,e as i,d as n,i as o,b as a,f as r,s as l,g as c,v as h,u,l as g,h as f,j as p,_ as m,k as x,T as b,m as _,H as y,P as v,t as k,n as M,o as S,p as w,q as C,w as D,x as P,y as A,z as L,A as T,B as O,C as E,D as R,E as I,F as B,G as F,I as z,J as V,K as N,L as W,M as H,N as j,O as $,Q as U,R as Y,S as X,U as K,V as G,W as q,X as J,Y as Z,Z as Q,$ as tt,a0 as et,a1 as st,a2 as it,a3 as nt,a4 as ot,a5 as at,a6 as rt,a7 as lt,a8 as ct,a9 as ht,aa as dt,ab as ut,ac as gt,ad as ft,ae as pt,af as mt,ag as xt,ah as bt,ai as _t,aj as yt,ak as vt,al as kt,am as Mt,an as St,ao as wt,ap as Ct,aq as Dt,ar as Pt,as as At,at as Lt,au as Tt,av as Ot,aw as Et,ax as Rt,ay as It,az as Bt,aA as Ft,aB as zt,aC as Vt,aD as Nt,aE as Wt,aF as Ht,aG as jt,aH as $t,aI as Ut,aJ as Yt,aK as Xt,aL as Kt,aM as Gt,aN as qt,aO as Jt}from"../_/16cda191.js";export{d as defaults}from"../_/16cda191.js";class Animator{constructor(){this._request=null;this._charts=new Map;this._running=false;this._lastDate=void 0}_notify(t,e,s,i){const n=e.listeners[i];const o=e.duration;n.forEach((i=>i({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(s-e.start,o)})))}_refresh(){if(!this._request){this._running=true;this._request=t.call(window,(()=>{this._update();this._request=null;this._running&&this._refresh()}))}}_update(t=Date.now()){let e=0;this._charts.forEach(((s,i)=>{if(!s.running||!s.items.length)return;const n=s.items;let o=n.length-1;let a=false;let r;for(;o>=0;--o){r=n[o];if(r._active){r._total>s.duration&&(s.duration=r._total);r.tick(t);a=true}else{n[o]=n[n.length-1];n.pop()}}if(a){i.draw();this._notify(i,s,t,"progress")}if(!n.length){s.running=false;this._notify(i,s,t,"complete");s.initial=false}e+=n.length}));this._lastDate=t;0===e&&(this._running=false)}_getAnims(t){const e=this._charts;let s=e.get(t);if(!s){s={running:false,initial:true,items:[],listeners:{complete:[],progress:[]}};e.set(t,s)}return s}listen(t,e,s){this._getAnims(t).listeners[e].push(s)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);if(e){e.running=true;e.start=Date.now();e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0);this._refresh()}}running(t){if(!this._running)return false;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const s=e.items;let i=s.length-1;for(;i>=0;--i)s[i].cancel();e.items=[];this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}}var Zt=new Animator;const Qt="transparent";const te={boolean(t,e,s){return s>.5?e:t},color(t,s,i){const n=e(t||Qt);const o=n.valid&&e(s||Qt);return o&&o.valid?o.mix(n,i).hexString():s},number(t,e,s){return t+(e-t)*s}};class Animation{constructor(t,e,n,o){const a=e[n];o=s([t.to,o,a,t.from]);const r=s([t.from,a,o]);this._active=true;this._fn=t.fn||te[t.type||typeof r];this._easing=i[t.easing]||i.linear;this._start=Math.floor(Date.now()+(t.delay||0));this._duration=this._total=Math.floor(t.duration);this._loop=!!t.loop;this._target=e;this._prop=n;this._from=r;this._to=o;this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(false);const n=this._target[this._prop];const o=i-this._start;const a=this._duration-o;this._start=i;this._duration=Math.floor(Math.max(a,t.duration));this._total+=o;this._loop=!!t.loop;this._to=s([t.to,e,n,t.from]);this._from=s([t.from,n,e])}}cancel(){if(this._active){this.tick(Date.now());this._active=false;this._notify(false)}}tick(t){const e=t-this._start;const s=this._duration;const i=this._prop;const n=this._from;const o=this._loop;const a=this._to;let r;this._active=n!==a&&(o||e<s);if(this._active)if(e<0)this._target[i]=n;else{r=e/s%2;r=o&&r>1?2-r:r;r=this._easing(Math.min(1,Math.max(0,r)));this._target[i]=this._fn(n,a,r)}else{this._target[i]=a;this._notify(true)}}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,s)=>{t.push({res:e,rej:s})}))}_notify(t){const e=t?"res":"rej";const s=this._promises||[];for(let t=0;t<s.length;t++)s[t][e]()}}const ee=["x","y","borderWidth","radius","tension"];const se=["color","borderColor","backgroundColor"];n.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0});const ie=Object.keys(n.animation);n.describe("animation",{_fallback:false,_indexable:false,_scriptable:t=>"onProgress"!==t&&"onComplete"!==t&&"fn"!==t});n.set("animations",{colors:{type:"color",properties:se},numbers:{type:"number",properties:ee}});n.describe("animations",{_fallback:"animation"});n.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>0|t}}}});class Animations{constructor(t,e){this._chart=t;this._properties=new Map;this.configure(e)}configure(t){if(!o(t))return;const e=this._properties;Object.getOwnPropertyNames(t).forEach((s=>{const i=t[s];if(!o(i))return;const n={};for(const t of ie)n[t]=i[t];(a(i.properties)&&i.properties||[s]).forEach((t=>{t!==s&&e.has(t)||e.set(t,n)}))}))}_animateOptions(t,e){const s=e.options;const i=resolveTargetOptions(t,s);if(!i)return[];const n=this._createAnimations(i,s);s.$shared&&awaitAll(t.options.$animations,s).then((()=>{t.options=s}),(()=>{}));return n}_createAnimations(t,e){const s=this._properties;const i=[];const n=t.$animations||(t.$animations={});const o=Object.keys(e);const a=Date.now();let r;for(r=o.length-1;r>=0;--r){const l=o[r];if("$"===l.charAt(0))continue;if("options"===l){i.push(...this._animateOptions(t,e));continue}const c=e[l];let h=n[l];const d=s.get(l);if(h){if(d&&h.active()){h.update(d,c,a);continue}h.cancel()}if(d&&d.duration){n[l]=h=new Animation(d,t,l,c);i.push(h)}else t[l]=c}return i}update(t,e){if(0===this._properties.size){Object.assign(t,e);return}const s=this._createAnimations(t,e);if(s.length){Zt.add(this._chart,s);return true}}}function awaitAll(t,e){const s=[];const i=Object.keys(e);for(let e=0;e<i.length;e++){const n=t[i[e]];n&&n.active()&&s.push(n.wait())}return Promise.all(s)}function resolveTargetOptions(t,e){if(!e)return;let s=t.options;if(s){s.$shared&&(t.options=s=Object.assign({},s,{$shared:false,$animations:{}}));return s}t.options=e}function scaleClip(t,e){const s=t&&t.options||{};const i=s.reverse;const n=void 0===s.min?e:0;const o=void 0===s.max?e:0;return{start:i?o:n,end:i?n:o}}function defaultClip(t,e,s){if(false===s)return false;const i=scaleClip(t,s);const n=scaleClip(e,s);return{top:n.end,right:i.end,bottom:n.start,left:i.start}}function toClip(t){let e,s,i,n;if(o(t)){e=t.top;s=t.right;i=t.bottom;n=t.left}else e=s=i=n=t;return{top:e,right:s,bottom:i,left:n,disabled:false===t}}function getSortedDatasetIndices(t,e){const s=[];const i=t._getSortedDatasetMetas(e);let n,o;for(n=0,o=i.length;n<o;++n)s.push(i[n].index);return s}function applyStack(t,e,s,i={}){const n=t.keys;const o="single"===i.mode;let a,c,h,d;if(null!==e){for(a=0,c=n.length;a<c;++a){h=+n[a];if(h===s){if(i.all)continue;break}d=t.values[h];r(d)&&(o||0===e||l(e)===l(d))&&(e+=d)}return e}}function convertObjectDataToArray(t){const e=Object.keys(t);const s=new Array(e.length);let i,n,o;for(i=0,n=e.length;i<n;++i){o=e[i];s[i]={x:o,y:t[o]}}return s}function isStacked(t,e){const s=t&&t.options.stacked;return s||void 0===s&&void 0!==e.stack}function getStackKey(t,e,s){return`${t.id}.${e.id}.${s.stack||s.type}`}function getUserBounds(t){const{min:e,max:s,minDefined:i,maxDefined:n}=t.getUserBounds();return{min:i?e:Number.NEGATIVE_INFINITY,max:n?s:Number.POSITIVE_INFINITY}}function getOrCreateStack(t,e,s){const i=t[e]||(t[e]={});return i[s]||(i[s]={})}function getLastIndexInStack(t,e,s,i){for(const n of e.getMatchingVisibleMetas(i).reverse()){const e=t[n.index];if(s&&e>0||!s&&e<0)return n.index}return null}function updateStacks(t,e){const{chart:s,_cachedMeta:i}=t;const n=s._stacks||(s._stacks={});const{iScale:o,vScale:a,index:r}=i;const l=o.axis;const c=a.axis;const h=getStackKey(o,a,i);const d=e.length;let u;for(let t=0;t<d;++t){const s=e[t];const{[l]:o,[c]:d}=s;const g=s._stacks||(s._stacks={});u=g[c]=getOrCreateStack(n,h,o);u[r]=d;u._top=getLastIndexInStack(u,a,true,i.type);u._bottom=getLastIndexInStack(u,a,false,i.type)}}function getFirstScaleId(t,e){const s=t.scales;return Object.keys(s).filter((t=>s[t].axis===e)).shift()}function createDatasetContext(t,e){return c(t,{active:false,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}function createDataContext(t,e,s){return c(t,{active:false,dataIndex:e,parsed:void 0,raw:void 0,element:s,index:e,mode:"default",type:"data"})}function clearStacks(t,e){const s=t.controller.index;const i=t.vScale&&t.vScale.axis;if(i){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[i]||void 0===e[i][s])return;delete e[i][s]}}}const isDirectUpdateMode=t=>"reset"===t||"none"===t;const cloneIfNotShared=(t,e)=>e?t:Object.assign({},t);const createStack=(t,e,s)=>t&&!e.hidden&&e._stacked&&{keys:getSortedDatasetIndices(s,true),values:null};class DatasetController{constructor(t,e){this.chart=t;this._ctx=t.ctx;this.index=e;this._cachedDataOpts={};this._cachedMeta=this.getMeta();this._type=this._cachedMeta.type;this.options=void 0;this._parsing=false;this._data=void 0;this._objectData=void 0;this._sharedOptions=void 0;this._drawStart=void 0;this._drawCount=void 0;this.enableOptionSharing=false;this.supportsDecimation=false;this.$context=void 0;this._syncList=[];this.initialize()}initialize(){const t=this._cachedMeta;this.configure();this.linkScales();t._stacked=isStacked(t.vScale,t);this.addElements()}updateIndex(t){this.index!==t&&clearStacks(this._cachedMeta);this.index=t}linkScales(){const t=this.chart;const e=this._cachedMeta;const s=this.getDataset();const chooseId=(t,e,s,i)=>"x"===t?e:"r"===t?i:s;const i=e.xAxisID=h(s.xAxisID,getFirstScaleId(t,"x"));const n=e.yAxisID=h(s.yAxisID,getFirstScaleId(t,"y"));const o=e.rAxisID=h(s.rAxisID,getFirstScaleId(t,"r"));const a=e.indexAxis;const r=e.iAxisID=chooseId(a,i,n,o);const l=e.vAxisID=chooseId(a,n,i,o);e.xScale=this.getScaleForId(i);e.yScale=this.getScaleForId(n);e.rScale=this.getScaleForId(o);e.iScale=this.getScaleForId(r);e.vScale=this.getScaleForId(l)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&u(this._data,this);t._stacked&&clearStacks(t)}_dataCheck(){const t=this.getDataset();const e=t.data||(t.data=[]);const s=this._data;if(o(e))this._data=convertObjectDataToArray(e);else if(s!==e){if(s){u(s,this);const t=this._cachedMeta;clearStacks(t);t._parsed=[]}e&&Object.isExtensible(e)&&g(e,this);this._syncList=[];this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck();this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta;const s=this.getDataset();let i=false;this._dataCheck();const n=e._stacked;e._stacked=isStacked(e.vScale,e);if(e.stack!==s.stack){i=true;clearStacks(e);e.stack=s.stack}this._resyncElements(t);(i||n!==e._stacked)&&updateStacks(this,e._parsed)}configure(){const t=this.chart.config;const e=t.datasetScopeKeys(this._type);const s=t.getOptionScopes(this.getDataset(),e,true);this.options=t.createResolver(s,this.getContext());this._parsing=this.options.parsing;this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:s,_data:i}=this;const{iScale:n,_stacked:r}=s;const l=n.axis;let c=0===t&&e===i.length||s._sorted;let h=t>0&&s._parsed[t-1];let d,u,g;if(false===this._parsing){s._parsed=i;s._sorted=true;g=i}else{g=a(i[t])?this.parseArrayData(s,i,t,e):o(i[t])?this.parseObjectData(s,i,t,e):this.parsePrimitiveData(s,i,t,e);const isNotInOrderComparedToPrev=()=>null===u[l]||h&&u[l]<h[l];for(d=0;d<e;++d){s._parsed[d+t]=u=g[d];if(c){isNotInOrderComparedToPrev()&&(c=false);h=u}}s._sorted=c}r&&updateStacks(this,g)}parsePrimitiveData(t,e,s,i){const{iScale:n,vScale:o}=t;const a=n.axis;const r=o.axis;const l=n.getLabels();const c=n===o;const h=new Array(i);let d,u,g;for(d=0,u=i;d<u;++d){g=d+s;h[d]={[a]:c||n.parse(l[g],g),[r]:o.parse(e[g],g)}}return h}parseArrayData(t,e,s,i){const{xScale:n,yScale:o}=t;const a=new Array(i);let r,l,c,h;for(r=0,l=i;r<l;++r){c=r+s;h=e[c];a[r]={x:n.parse(h[0],c),y:o.parse(h[1],c)}}return a}parseObjectData(t,e,s,i){const{xScale:n,yScale:o}=t;const{xAxisKey:a="x",yAxisKey:r="y"}=this._parsing;const l=new Array(i);let c,h,d,u;for(c=0,h=i;c<h;++c){d=c+s;u=e[d];l[c]={x:n.parse(f(u,a),d),y:o.parse(f(u,r),d)}}return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,s){const i=this.chart;const n=this._cachedMeta;const o=e[t.axis];const a={keys:getSortedDatasetIndices(i,true),values:e._stacks[t.axis]};return applyStack(a,o,n.index,{mode:s})}updateRangeFromParsed(t,e,s,i){const n=s[e.axis];let o=null===n?NaN:n;const a=i&&s._stacks[e.axis];if(i&&a){i.values=a;o=applyStack(i,n,this._cachedMeta.index)}t.min=Math.min(t.min,o);t.max=Math.max(t.max,o)}getMinMax(t,e){const s=this._cachedMeta;const i=s._parsed;const n=s._sorted&&t===s.iScale;const o=i.length;const a=this._getOtherScale(t);const l=createStack(e,s,this.chart);const c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};const{min:h,max:d}=getUserBounds(a);let u,g;function _skip(){g=i[u];const e=g[a.axis];return!r(g[t.axis])||h>e||d<e}for(u=0;u<o;++u)if(!_skip()){this.updateRangeFromParsed(c,t,g,l);if(n)break}if(n)for(u=o-1;u>=0;--u)if(!_skip()){this.updateRangeFromParsed(c,t,g,l);break}return c}getAllParsedValues(t){const e=this._cachedMeta._parsed;const s=[];let i,n,o;for(i=0,n=e.length;i<n;++i){o=e[i][t.axis];r(o)&&s.push(o)}return s}getMaxOverflow(){return false}getLabelAndValue(t){const e=this._cachedMeta;const s=e.iScale;const i=e.vScale;const n=this.getParsed(t);return{label:s?""+s.getLabelForValue(n[s.axis]):"",value:i?""+i.getLabelForValue(n[i.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default");e._clip=toClip(h(this.options.clip,defaultClip(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx;const e=this.chart;const s=this._cachedMeta;const i=s.data||[];const n=e.chartArea;const o=[];const a=this._drawStart||0;const r=this._drawCount||i.length-a;const l=this.options.drawActiveElementsOnTop;let c;s.dataset&&s.dataset.draw(t,n,a,r);for(c=a;c<a+r;++c){const e=i[c];e.hidden||(e.active&&l?o.push(e):e.draw(t,n))}for(c=0;c<o.length;++c)o[c].draw(t,n)}getStyle(t,e){const s=e?"active":"default";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(s):this.resolveDataElementOptions(t||0,s)}getContext(t,e,s){const i=this.getDataset();let n;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=createDataContext(this.getContext(),t,e));n.parsed=this.getParsed(t);n.raw=i.data[t];n.index=n.dataIndex=t}else{n=this.$context||(this.$context=createDatasetContext(this.chart.getContext(),this.index));n.dataset=i;n.index=n.datasetIndex=this.index}n.active=!!e;n.mode=s;return n}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="default",s){const i="active"===e;const o=this._cachedDataOpts;const a=t+"-"+e;const r=o[a];const l=this.enableOptionSharing&&p(s);if(r)return cloneIfNotShared(r,l);const c=this.chart.config;const h=c.datasetElementScopeKeys(this._type,t);const d=i?[`${t}Hover`,"hover",t,""]:[t,""];const u=c.getOptionScopes(this.getDataset(),h);const g=Object.keys(n.elements[t]);const context=()=>this.getContext(s,i);const f=c.resolveNamedOptions(u,g,context,d);if(f.$shared){f.$shared=l;o[a]=Object.freeze(cloneIfNotShared(f,l))}return f}_resolveAnimations(t,e,s){const i=this.chart;const n=this._cachedDataOpts;const o=`animation-${e}`;const a=n[o];if(a)return a;let r;if(false!==i.options.animation){const i=this.chart.config;const n=i.datasetAnimationScopeKeys(this._type,e);const o=i.getOptionScopes(this.getDataset(),n);r=i.createResolver(o,this.getContext(t,s,e))}const l=new Animations(i,r&&r.animations);r&&r._cacheable&&(n[o]=Object.freeze(l));return l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||isDirectUpdateMode(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const s=this.resolveDataElementOptions(t,e);const i=this._sharedOptions;const n=this.getSharedOptions(s);const o=this.includeOptions(e,n)||n!==i;this.updateSharedOptions(n,e,s);return{sharedOptions:n,includeOptions:o}}updateElement(t,e,s,i){isDirectUpdateMode(i)?Object.assign(t,s):this._resolveAnimations(e,i).update(t,s)}updateSharedOptions(t,e,s){t&&!isDirectUpdateMode(e)&&this._resolveAnimations(void 0,e).update(t,s)}_setStyle(t,e,s,i){t.active=i;const n=this.getStyle(e,i);this._resolveAnimations(e,s,i).update(t,{options:!i&&this.getSharedOptions(n)||n})}removeHoverStyle(t,e,s){this._setStyle(t,s,"active",false)}setHoverStyle(t,e,s){this._setStyle(t,s,"active",true)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",false)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",true)}_resyncElements(t){const e=this._data;const s=this._cachedMeta.data;for(const[t,e,s]of this._syncList)this[t](e,s);this._syncList=[];const i=s.length;const n=e.length;const o=Math.min(n,i);o&&this.parse(0,o);n>i?this._insertElements(i,n-i,t):n<i&&this._removeElements(n,i-n)}_insertElements(t,e,s=true){const i=this._cachedMeta;const n=i.data;const o=t+e;let a;const move=t=>{t.length+=e;for(a=t.length-1;a>=o;a--)t[a]=t[a-e]};move(n);for(a=t;a<o;++a)n[a]=new this.dataElementType;this._parsing&&move(i._parsed);this.parse(t,e);s&&this.updateElements(n,t,e,"reset")}updateElements(t,e,s,i){}_removeElements(t,e){const s=this._cachedMeta;if(this._parsing){const i=s._parsed.splice(t,e);s._stacked&&clearStacks(s,i)}s.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,s,i]=t;this[e](s,i)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const s=arguments.length-2;s&&this._sync(["_insertElements",t,s])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}DatasetController.defaults={};DatasetController.prototype.datasetElementType=null;DatasetController.prototype.dataElementType=null;function getAllScaleValues(t,e){if(!t._cache.$bar){const s=t.getMatchingVisibleMetas(e);let i=[];for(let e=0,n=s.length;e<n;e++)i=i.concat(s[e].controller.getAllParsedValues(t));t._cache.$bar=m(i.sort(((t,e)=>t-e)))}return t._cache.$bar}function computeMinSampleSize(t){const e=t.iScale;const s=getAllScaleValues(e,t.type);let i=e._length;let n,o,a,r;const updateMinAndPrev=()=>{if(32767!==a&&-32768!==a){p(r)&&(i=Math.min(i,Math.abs(a-r)||i));r=a}};for(n=0,o=s.length;n<o;++n){a=e.getPixelForValue(s[n]);updateMinAndPrev()}r=void 0;for(n=0,o=e.ticks.length;n<o;++n){a=e.getPixelForTick(n);updateMinAndPrev()}return i}function computeFitCategoryTraits(t,e,s,i){const n=s.barThickness;let o,a;if(x(n)){o=e.min*s.categoryPercentage;a=s.barPercentage}else{o=n*i;a=1}return{chunk:o/i,ratio:a,start:e.pixels[t]-o/2}}function computeFlexCategoryTraits(t,e,s,i){const n=e.pixels;const o=n[t];let a=t>0?n[t-1]:null;let r=t<n.length-1?n[t+1]:null;const l=s.categoryPercentage;null===a&&(a=o-(null===r?e.end-e.start:r-o));null===r&&(r=o+o-a);const c=o-(o-Math.min(a,r))/2*l;const h=Math.abs(r-a)/2*l;return{chunk:h/i,ratio:s.barPercentage,start:c}}function parseFloatBar(t,e,s,i){const n=s.parse(t[0],i);const o=s.parse(t[1],i);const a=Math.min(n,o);const r=Math.max(n,o);let l=a;let c=r;if(Math.abs(a)>Math.abs(r)){l=r;c=a}e[s.axis]=c;e._custom={barStart:l,barEnd:c,start:n,end:o,min:a,max:r}}function parseValue(t,e,s,i){a(t)?parseFloatBar(t,e,s,i):e[s.axis]=s.parse(t,i);return e}function parseArrayOrPrimitive(t,e,s,i){const n=t.iScale;const o=t.vScale;const a=n.getLabels();const r=n===o;const l=[];let c,h,d,u;for(c=s,h=s+i;c<h;++c){u=e[c];d={};d[n.axis]=r||n.parse(a[c],c);l.push(parseValue(u,d,o,c))}return l}function isFloatBar(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function barSign(t,e,s){return 0!==t?l(t):(e.isHorizontal()?1:-1)*(e.min>=s?1:-1)}function borderProps(t){let e,s,i,n,o;if(t.horizontal){e=t.base>t.x;s="left";i="right"}else{e=t.base<t.y;s="bottom";i="top"}if(e){n="end";o="start"}else{n="start";o="end"}return{start:s,end:i,reverse:e,top:n,bottom:o}}function setBorderSkipped(t,e,s,i){let n=e.borderSkipped;const o={};if(!n){t.borderSkipped=o;return}if(true===n){t.borderSkipped={top:true,right:true,bottom:true,left:true};return}const{start:a,end:r,reverse:l,top:c,bottom:h}=borderProps(t);if("middle"===n&&s){t.enableBorderRadius=true;if((s._top||0)===i)n=c;else if((s._bottom||0)===i)n=h;else{o[parseEdge(h,a,r,l)]=true;n=c}}o[parseEdge(n,a,r,l)]=true;t.borderSkipped=o}function parseEdge(t,e,s,i){if(i){t=swap(t,e,s);t=startEnd(t,s,e)}else t=startEnd(t,e,s);return t}function swap(t,e,s){return t===e?s:t===s?e:t}function startEnd(t,e,s){return"start"===t?e:"end"===t?s:t}function setInflateAmount(t,{inflateAmount:e},s){t.inflateAmount="auto"===e?1===s?.33:0:e}class BarController extends DatasetController{parsePrimitiveData(t,e,s,i){return parseArrayOrPrimitive(t,e,s,i)}parseArrayData(t,e,s,i){return parseArrayOrPrimitive(t,e,s,i)}parseObjectData(t,e,s,i){const{iScale:n,vScale:o}=t;const{xAxisKey:a="x",yAxisKey:r="y"}=this._parsing;const l="x"===n.axis?a:r;const c="x"===o.axis?a:r;const h=[];let d,u,g,p;for(d=s,u=s+i;d<u;++d){p=e[d];g={};g[n.axis]=n.parse(f(p,l),d);h.push(parseValue(f(p,c),g,o,d))}return h}updateRangeFromParsed(t,e,s,i){super.updateRangeFromParsed(t,e,s,i);const n=s._custom;if(n&&e===this._cachedMeta.vScale){t.min=Math.min(t.min,n.min);t.max=Math.max(t.max,n.max)}}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta;const{iScale:s,vScale:i}=e;const n=this.getParsed(t);const o=n._custom;const a=isFloatBar(o)?"["+o.start+", "+o.end+"]":""+i.getLabelForValue(n[i.axis]);return{label:""+s.getLabelForValue(n[s.axis]),value:a}}initialize(){this.enableOptionSharing=true;super.initialize();const t=this._cachedMeta;t.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,s,i){const n="reset"===i;const{index:o,_cachedMeta:{vScale:a}}=this;const r=a.getBasePixel();const l=a.isHorizontal();const c=this._getRuler();const{sharedOptions:h,includeOptions:d}=this._getSharedOptions(e,i);for(let u=e;u<e+s;u++){const e=this.getParsed(u);const s=n||x(e[a.axis])?{base:r,head:r}:this._calculateBarValuePixels(u);const g=this._calculateBarIndexPixels(u,c);const f=(e._stacks||{})[a.axis];const p={horizontal:l,base:s.base,enableBorderRadius:!f||isFloatBar(e._custom)||o===f._top||o===f._bottom,x:l?s.head:g.center,y:l?g.center:s.head,height:l?g.size:Math.abs(s.size),width:l?Math.abs(s.size):g.size};d&&(p.options=h||this.resolveDataElementOptions(u,t[u].active?"active":i));const m=p.options||t[u].options;setBorderSkipped(p,m,f,o);setInflateAmount(p,m,c.ratio);this.updateElement(t[u],u,p,i)}}_getStacks(t,e){const{iScale:s}=this._cachedMeta;const i=s.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped));const n=s.options.stacked;const o=[];const skipNull=t=>{const s=t.controller.getParsed(e);const i=s&&s[t.vScale.axis];if(x(i)||isNaN(i))return true};for(const s of i)if(void 0===e||!skipNull(s)){(false===n||-1===o.indexOf(s.stack)||void 0===n&&void 0===s.stack)&&o.push(s.stack);if(s.index===t)break}o.length||o.push(void 0);return o}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,s){const i=this._getStacks(t,s);const n=void 0!==e?i.indexOf(e):-1;return-1===n?i.length-1:n}_getRuler(){const t=this.options;const e=this._cachedMeta;const s=e.iScale;const i=[];let n,o;for(n=0,o=e.data.length;n<o;++n)i.push(s.getPixelForValue(this.getParsed(n)[s.axis],n));const a=t.barThickness;const r=a||computeMinSampleSize(e);return{min:r,pixels:i,start:s._startPixel,end:s._endPixel,stackCount:this._getStackCount(),scale:s,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:s},options:{base:i,minBarLength:n}}=this;const o=i||0;const a=this.getParsed(t);const r=a._custom;const c=isFloatBar(r);let h=a[e.axis];let d=0;let u=s?this.applyStack(e,a,s):h;let g,f;if(u!==h){d=u-h;u=h}if(c){h=r.barStart;u=r.barEnd-r.barStart;0!==h&&l(h)!==l(r.barEnd)&&(d=0);d+=h}const p=x(i)||c?d:i;let m=e.getPixelForValue(p);g=this.chart.getDataVisibility(t)?e.getPixelForValue(d+u):m;f=g-m;if(Math.abs(f)<n){f=barSign(f,e,o)*n;h===o&&(m-=f/2);const t=e.getPixelForDecimal(0);const s=e.getPixelForDecimal(1);const i=Math.min(t,s);const a=Math.max(t,s);m=Math.max(Math.min(m,a),i);g=m+f}if(m===e.getPixelForValue(o)){const t=l(f)*e.getLineWidthForValue(o)/2;m+=t;f-=t}return{size:f,base:m,head:g,center:g+f/2}}_calculateBarIndexPixels(t,e){const s=e.scale;const i=this.options;const n=i.skipNull;const o=h(i.maxBarThickness,Infinity);let a,r;if(e.grouped){const s=n?this._getStackCount(t):e.stackCount;const l="flex"===i.barThickness?computeFlexCategoryTraits(t,e,i,s):computeFitCategoryTraits(t,e,i,s);const c=this._getStackIndex(this.index,this._cachedMeta.stack,n?t:void 0);a=l.start+l.chunk*c+l.chunk/2;r=Math.min(o,l.chunk*l.ratio)}else{a=s.getPixelForValue(this.getParsed(t)[s.axis],t);r=Math.min(o,e.min*e.ratio)}return{base:a-r/2,head:a+r/2,center:a,size:r}}draw(){const t=this._cachedMeta;const e=t.vScale;const s=t.data;const i=s.length;let n=0;for(;n<i;++n)null!==this.getParsed(n)[e.axis]&&s[n].draw(this._ctx)}}BarController.id="bar";BarController.defaults={datasetElementType:false,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:true,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};BarController.overrides={scales:{_index_:{type:"category",offset:true,grid:{offset:true}},_value_:{type:"linear",beginAtZero:true}}};class BubbleController extends DatasetController{initialize(){this.enableOptionSharing=true;super.initialize()}parsePrimitiveData(t,e,s,i){const n=super.parsePrimitiveData(t,e,s,i);for(let t=0;t<n.length;t++)n[t]._custom=this.resolveDataElementOptions(t+s).radius;return n}parseArrayData(t,e,s,i){const n=super.parseArrayData(t,e,s,i);for(let t=0;t<n.length;t++){const i=e[s+t];n[t]._custom=h(i[2],this.resolveDataElementOptions(t+s).radius)}return n}parseObjectData(t,e,s,i){const n=super.parseObjectData(t,e,s,i);for(let t=0;t<n.length;t++){const i=e[s+t];n[t]._custom=h(i&&i.r&&+i.r,this.resolveDataElementOptions(t+s).radius)}return n}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let s=t.length-1;s>=0;--s)e=Math.max(e,t[s].size(this.resolveDataElementOptions(s))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta;const{xScale:s,yScale:i}=e;const n=this.getParsed(t);const o=s.getLabelForValue(n.x);const a=i.getLabelForValue(n.y);const r=n._custom;return{label:e.label,value:"("+o+", "+a+(r?", "+r:"")+")"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,s,i){const n="reset"===i;const{iScale:o,vScale:a}=this._cachedMeta;const{sharedOptions:r,includeOptions:l}=this._getSharedOptions(e,i);const c=o.axis;const h=a.axis;for(let d=e;d<e+s;d++){const e=t[d];const s=!n&&this.getParsed(d);const u={};const g=u[c]=n?o.getPixelForDecimal(.5):o.getPixelForValue(s[c]);const f=u[h]=n?a.getBasePixel():a.getPixelForValue(s[h]);u.skip=isNaN(g)||isNaN(f);if(l){u.options=r||this.resolveDataElementOptions(d,e.active?"active":i);n&&(u.options.radius=0)}this.updateElement(e,d,u,i)}}resolveDataElementOptions(t,e){const s=this.getParsed(t);let i=super.resolveDataElementOptions(t,e);i.$shared&&(i=Object.assign({},i,{$shared:false}));const n=i.radius;"active"!==e&&(i.radius=0);i.radius+=h(s&&s._custom,n);return i}}BubbleController.id="bubble";BubbleController.defaults={datasetElementType:false,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}};BubbleController.overrides={scales:{x:{type:"linear"},y:{type:"linear"}},plugins:{tooltip:{callbacks:{title(){return""}}}}};function getRatioAndOffset(t,e,s){let i=1;let n=1;let o=0;let a=0;if(e<b){const r=t;const l=r+e;const c=Math.cos(r);const h=Math.sin(r);const d=Math.cos(l);const u=Math.sin(l);const calcMax=(t,e,i)=>_(t,r,l,true)?1:Math.max(e,e*s,i,i*s);const calcMin=(t,e,i)=>_(t,r,l,true)?-1:Math.min(e,e*s,i,i*s);const g=calcMax(0,c,d);const f=calcMax(y,h,u);const p=calcMin(v,c,d);const m=calcMin(v+y,h,u);i=(g-p)/2;n=(f-m)/2;o=-(g+p)/2;a=-(f+m)/2}return{ratioX:i,ratioY:n,offsetX:o,offsetY:a}}class DoughnutController extends DatasetController{constructor(t,e){super(t,e);this.enableOptionSharing=true;this.innerRadius=void 0;this.outerRadius=void 0;this.offsetX=void 0;this.offsetY=void 0}linkScales(){}parse(t,e){const s=this.getDataset().data;const i=this._cachedMeta;if(false===this._parsing)i._parsed=s;else{let getter=t=>+s[t];if(o(s[t])){const{key:t="value"}=this._parsing;getter=e=>+f(s[e],t)}let n,a;for(n=t,a=t+e;n<a;++n)i._parsed[n]=getter(n)}}_getRotation(){return k(this.options.rotation-90)}_getCircumference(){return k(this.options.circumference)}_getRotationExtents(){let t=b;let e=-b;for(let s=0;s<this.chart.data.datasets.length;++s)if(this.chart.isDatasetVisible(s)){const i=this.chart.getDatasetMeta(s).controller;const n=i._getRotation();const o=i._getCircumference();t=Math.min(t,n);e=Math.max(e,n+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart;const{chartArea:s}=e;const i=this._cachedMeta;const n=i.data;const o=this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing;const a=Math.max((Math.min(s.width,s.height)-o)/2,0);const r=Math.min(M(this.options.cutout,a),1);const l=this._getRingWeight(this.index);const{circumference:c,rotation:h}=this._getRotationExtents();const{ratioX:d,ratioY:u,offsetX:g,offsetY:f}=getRatioAndOffset(h,c,r);const p=(s.width-o)/d;const m=(s.height-o)/u;const x=Math.max(Math.min(p,m)/2,0);const b=S(this.options.radius,x);const _=Math.max(b*r,0);const y=(b-_)/this._getVisibleDatasetWeightTotal();this.offsetX=g*b;this.offsetY=f*b;i.total=this.calculateTotal();this.outerRadius=b-y*this._getRingWeightOffset(this.index);this.innerRadius=Math.max(this.outerRadius-y*l,0);this.updateElements(n,0,n.length,t)}_circumference(t,e){const s=this.options;const i=this._cachedMeta;const n=this._getCircumference();return e&&s.animation.animateRotate||!this.chart.getDataVisibility(t)||null===i._parsed[t]||i.data[t].hidden?0:this.calculateCircumference(i._parsed[t]*n/b)}updateElements(t,e,s,i){const n="reset"===i;const o=this.chart;const a=o.chartArea;const r=o.options;const l=r.animation;const c=(a.left+a.right)/2;const h=(a.top+a.bottom)/2;const d=n&&l.animateScale;const u=d?0:this.innerRadius;const g=d?0:this.outerRadius;const{sharedOptions:f,includeOptions:p}=this._getSharedOptions(e,i);let m=this._getRotation();let x;for(x=0;x<e;++x)m+=this._circumference(x,n);for(x=e;x<e+s;++x){const e=this._circumference(x,n);const s=t[x];const o={x:c+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:g,innerRadius:u};p&&(o.options=f||this.resolveDataElementOptions(x,s.active?"active":i));m+=e;this.updateElement(s,x,o,i)}}calculateTotal(){const t=this._cachedMeta;const e=t.data;let s=0;let i;for(i=0;i<e.length;i++){const n=t._parsed[i];null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}return s}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?b*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta;const s=this.chart;const i=s.data.labels||[];const n=w(e._parsed[t],s.options.locale);return{label:i[t]||"",value:n}}getMaxBorderWidth(t){let e=0;const s=this.chart;let i,n,o,a,r;if(!t)for(i=0,n=s.data.datasets.length;i<n;++i)if(s.isDatasetVisible(i)){o=s.getDatasetMeta(i);t=o.data;a=o.controller;break}if(!t)return 0;for(i=0,n=t.length;i<n;++i){r=a.resolveDataElementOptions(i);"inner"!==r.borderAlign&&(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0))}return e}getMaxOffset(t){let e=0;for(let s=0,i=t.length;s<i;++s){const t=this.resolveDataElementOptions(s);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let s=0;s<t;++s)this.chart.isDatasetVisible(s)&&(e+=this._getRingWeight(s));return e}_getRingWeight(t){return Math.max(h(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}DoughnutController.id="doughnut";DoughnutController.defaults={datasetElementType:false,dataElementType:"arc",animation:{animateRotate:true,animateScale:false},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};DoughnutController.descriptors={_scriptable:t=>"spacing"!==t,_indexable:t=>"spacing"!==t};DoughnutController.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:s}}=t.legend.options;return e.labels.map(((e,i)=>{const n=t.getDatasetMeta(0);const o=n.controller.getStyle(i);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,lineWidth:o.borderWidth,pointStyle:s,hidden:!t.getDataVisibility(i),index:i}}))}return[]}},onClick(t,e,s){s.chart.toggleDataVisibility(e.index);s.chart.update()}},tooltip:{callbacks:{title(){return""},label(t){let e=t.label;const s=": "+t.formattedValue;if(a(e)){e=e.slice();e[0]+=s}else e+=s;return e}}}}};class LineController extends DatasetController{initialize(){this.enableOptionSharing=true;this.supportsDecimation=true;super.initialize()}update(t){const e=this._cachedMeta;const{dataset:s,data:i=[],_dataset:n}=e;const o=this.chart._animationsDisabled;let{start:a,count:r}=C(e,i,o);this._drawStart=a;this._drawCount=r;if(D(e)){a=0;r=i.length}s._chart=this.chart;s._datasetIndex=this.index;s._decimated=!!n._decimated;s.points=i;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0);l.segment=this.options.segment;this.updateElement(s,void 0,{animated:!o,options:l},t);this.updateElements(i,a,r,t)}updateElements(t,e,s,i){const n="reset"===i;const{iScale:o,vScale:a,_stacked:r,_dataset:l}=this._cachedMeta;const{sharedOptions:c,includeOptions:h}=this._getSharedOptions(e,i);const d=o.axis;const u=a.axis;const{spanGaps:g,segment:f}=this.options;const p=P(g)?g:Number.POSITIVE_INFINITY;const m=this.chart._animationsDisabled||n||"none"===i;let b=e>0&&this.getParsed(e-1);for(let g=e;g<e+s;++g){const e=t[g];const s=this.getParsed(g);const _=m?e:{};const y=x(s[u]);const v=_[d]=o.getPixelForValue(s[d],g);const k=_[u]=n||y?a.getBasePixel():a.getPixelForValue(r?this.applyStack(a,s,r):s[u],g);_.skip=isNaN(v)||isNaN(k)||y;_.stop=g>0&&Math.abs(s[d]-b[d])>p;if(f){_.parsed=s;_.raw=l.data[g]}h&&(_.options=c||this.resolveDataElementOptions(g,e.active?"active":i));m||this.updateElement(e,g,_,i);b=s}}getMaxOverflow(){const t=this._cachedMeta;const e=t.dataset;const s=e.options&&e.options.borderWidth||0;const i=t.data||[];if(!i.length)return s;const n=i[0].size(this.resolveDataElementOptions(0));const o=i[i.length-1].size(this.resolveDataElementOptions(i.length-1));return Math.max(s,n,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis);super.draw()}}LineController.id="line";LineController.defaults={datasetElementType:"line",dataElementType:"point",showLine:true,spanGaps:false};LineController.overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};class PolarAreaController extends DatasetController{constructor(t,e){super(t,e);this.innerRadius=void 0;this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta;const s=this.chart;const i=s.data.labels||[];const n=w(e._parsed[t].r,s.options.locale);return{label:i[t]||"",value:n}}parseObjectData(t,e,s,i){return A.bind(this)(t,e,s,i)}update(t){const e=this._cachedMeta.data;this._updateRadius();this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta;const e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};t.data.forEach(((t,s)=>{const i=this.getParsed(s).r;if(!isNaN(i)&&this.chart.getDataVisibility(s)){i<e.min&&(e.min=i);i>e.max&&(e.max=i)}}));return e}_updateRadius(){const t=this.chart;const e=t.chartArea;const s=t.options;const i=Math.min(e.right-e.left,e.bottom-e.top);const n=Math.max(i/2,0);const o=Math.max(s.cutoutPercentage?n/100*s.cutoutPercentage:1,0);const a=(n-o)/t.getVisibleDatasetCount();this.outerRadius=n-a*this.index;this.innerRadius=this.outerRadius-a}updateElements(t,e,s,i){const n="reset"===i;const o=this.chart;const a=o.options;const r=a.animation;const l=this._cachedMeta.rScale;const c=l.xCenter;const h=l.yCenter;const d=l.getIndexAngle(0)-.5*v;let u=d;let g;const f=360/this.countVisibleElements();for(g=0;g<e;++g)u+=this._computeAngle(g,i,f);for(g=e;g<e+s;g++){const e=t[g];let s=u;let a=u+this._computeAngle(g,i,f);let p=o.getDataVisibility(g)?l.getDistanceFromCenterForValue(this.getParsed(g).r):0;u=a;if(n){r.animateScale&&(p=0);r.animateRotate&&(s=a=d)}const m={x:c,y:h,innerRadius:0,outerRadius:p,startAngle:s,endAngle:a,options:this.resolveDataElementOptions(g,e.active?"active":i)};this.updateElement(e,g,m,i)}}countVisibleElements(){const t=this._cachedMeta;let e=0;t.data.forEach(((t,s)=>{!isNaN(this.getParsed(s).r)&&this.chart.getDataVisibility(s)&&e++}));return e}_computeAngle(t,e,s){return this.chart.getDataVisibility(t)?k(this.resolveDataElementOptions(t,e).angle||s):0}}PolarAreaController.id="polarArea";PolarAreaController.defaults={dataElementType:"arc",animation:{animateRotate:true,animateScale:true},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0};PolarAreaController.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:s}}=t.legend.options;return e.labels.map(((e,i)=>{const n=t.getDatasetMeta(0);const o=n.controller.getStyle(i);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,lineWidth:o.borderWidth,pointStyle:s,hidden:!t.getDataVisibility(i),index:i}}))}return[]}},onClick(t,e,s){s.chart.toggleDataVisibility(e.index);s.chart.update()}},tooltip:{callbacks:{title(){return""},label(t){return t.chart.data.labels[t.dataIndex]+": "+t.formattedValue}}}},scales:{r:{type:"radialLinear",angleLines:{display:false},beginAtZero:true,grid:{circular:true},pointLabels:{display:false},startAngle:0}}};class PieController extends DoughnutController{}PieController.id="pie";PieController.defaults={cutout:0,rotation:0,circumference:360,radius:"100%"};class RadarController extends DatasetController{getLabelAndValue(t){const e=this._cachedMeta.vScale;const s=this.getParsed(t);return{label:e.getLabels()[t],value:""+e.getLabelForValue(s[e.axis])}}parseObjectData(t,e,s,i){return A.bind(this)(t,e,s,i)}update(t){const e=this._cachedMeta;const s=e.dataset;const i=e.data||[];const n=e.iScale.getLabels();s.points=i;if("resize"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const o={_loop:true,_fullLoop:n.length===i.length,options:e};this.updateElement(s,void 0,o,t)}this.updateElements(i,0,i.length,t)}updateElements(t,e,s,i){const n=this._cachedMeta.rScale;const o="reset"===i;for(let a=e;a<e+s;a++){const e=t[a];const s=this.resolveDataElementOptions(a,e.active?"active":i);const r=n.getPointPositionForValue(a,this.getParsed(a).r);const l=o?n.xCenter:r.x;const c=o?n.yCenter:r.y;const h={x:l,y:c,angle:r.angle,skip:isNaN(l)||isNaN(c),options:s};this.updateElement(e,a,h,i)}}}RadarController.id="radar";RadarController.defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:true,elements:{line:{fill:"start"}}};RadarController.overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};class Element{constructor(){this.x=void 0;this.y=void 0;this.active=false;this.options=void 0;this.$animations=void 0}tooltipPosition(t){const{x:e,y:s}=this.getProps(["x","y"],t);return{x:e,y:s}}hasValue(){return P(this.x)&&P(this.y)}getProps(t,e){const s=this.$animations;if(!e||!s)return this;const i={};t.forEach((t=>{i[t]=s[t]&&s[t].active()?s[t]._to:this[t]}));return i}}Element.defaults={};Element.defaultRoutes=void 0;const ne={values(t){return a(t)?t:""+t},numeric(t,e,s){if(0===t)return"0";const i=this.chart.options.locale;let n;let o=t;if(s.length>1){const e=Math.max(Math.abs(s[0].value),Math.abs(s[s.length-1].value));(e<1e-4||e>1e15)&&(n="scientific");o=calculateDelta(t,s)}const a=L(Math.abs(o));const r=Math.max(Math.min(-1*Math.floor(a),20),0);const l={notation:n,minimumFractionDigits:r,maximumFractionDigits:r};Object.assign(l,this.options.ticks.format);return w(t,i,l)},logarithmic(t,e,s){if(0===t)return"0";const i=t/Math.pow(10,Math.floor(L(t)));return 1===i||2===i||5===i?ne.numeric.call(this,t,e,s):""}};function calculateDelta(t,e){let s=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(s)>=1&&t!==Math.floor(t)&&(s=t-Math.floor(t));return s}var oe={formatters:ne};n.set("scale",{display:true,offset:false,reverse:false,beginAtZero:false,bounds:"ticks",grace:0,grid:{display:true,lineWidth:1,drawBorder:true,drawOnChartArea:true,drawTicks:true,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:false,borderDash:[],borderDashOffset:0,borderWidth:1},title:{display:false,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:false,textStrokeWidth:0,textStrokeColor:"",padding:3,display:true,autoSkip:true,autoSkipPadding:3,labelOffset:0,callback:oe.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:false,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}});n.route("scale.ticks","color","","color");n.route("scale.grid","color","","borderColor");n.route("scale.grid","borderColor","","borderColor");n.route("scale.title","color","","color");n.describe("scale",{_fallback:false,_scriptable:t=>!t.startsWith("before")&&!t.startsWith("after")&&"callback"!==t&&"parser"!==t,_indexable:t=>"borderDash"!==t&&"tickBorderDash"!==t});n.describe("scales",{_fallback:"scale"});n.describe("scale.ticks",{_scriptable:t=>"backdropPadding"!==t&&"callback"!==t,_indexable:t=>"backdropPadding"!==t});function autoSkip(t,e){const s=t.options.ticks;const i=s.maxTicksLimit||determineMaxTicks(t);const n=s.major.enabled?getMajorIndices(e):[];const o=n.length;const a=n[0];const r=n[o-1];const l=[];if(o>i){skipMajors(e,l,n,o/i);return l}const c=calculateSpacing(n,e,i);if(o>0){let t,s;const i=o>1?Math.round((r-a)/(o-1)):null;skip(e,l,c,x(i)?0:a-i,a);for(t=0,s=o-1;t<s;t++)skip(e,l,c,n[t],n[t+1]);skip(e,l,c,r,x(i)?e.length:r+i);return l}skip(e,l,c);return l}function determineMaxTicks(t){const e=t.options.offset;const s=t._tickSize();const i=t._length/s+(e?0:1);const n=t._maxLength/s;return Math.floor(Math.min(i,n))}function calculateSpacing(t,e,s){const i=getEvenSpacing(t);const n=e.length/s;if(!i)return Math.max(n,1);const o=T(i);for(let t=0,e=o.length-1;t<e;t++){const e=o[t];if(e>n)return e}return Math.max(n,1)}function getMajorIndices(t){const e=[];let s,i;for(s=0,i=t.length;s<i;s++)t[s].major&&e.push(s);return e}function skipMajors(t,e,s,i){let n=0;let o=s[0];let a;i=Math.ceil(i);for(a=0;a<t.length;a++)if(a===o){e.push(t[a]);n++;o=s[n*i]}}function skip(t,e,s,i,n){const o=h(i,0);const a=Math.min(h(n,t.length),t.length);let r=0;let l,c,d;s=Math.ceil(s);if(n){l=n-i;s=l/Math.floor(l/s)}d=o;while(d<0){r++;d=Math.round(o+r*s)}for(c=Math.max(o,0);c<a;c++)if(c===d){e.push(t[c]);r++;d=Math.round(o+r*s)}}function getEvenSpacing(t){const e=t.length;let s,i;if(e<2)return false;for(i=t[0],s=1;s<e;++s)if(t[s]-t[s-1]!==i)return false;return i}const reverseAlign=t=>"left"===t?"right":"right"===t?"left":t;const offsetFromEdge=(t,e,s)=>"top"===e||"left"===e?t[e]+s:t[e]-s;function sample(t,e){const s=[];const i=t.length/e;const n=t.length;let o=0;for(;o<n;o+=i)s.push(t[Math.floor(o)]);return s}function getPixelForGridLine(t,e,s){const i=t.ticks.length;const n=Math.min(e,i-1);const o=t._startPixel;const a=t._endPixel;const r=1e-6;let l=t.getPixelForTick(n);let c;if(s){c=1===i?Math.max(l-o,a-l):0===e?(t.getPixelForTick(1)-l)/2:(l-t.getPixelForTick(n-1))/2;l+=n<e?c:-c;if(l<o-r||l>a+r)return}return l}function garbageCollect(t,e){O(t,(t=>{const s=t.gc;const i=s.length/2;let n;if(i>e){for(n=0;n<i;++n)delete t.data[s[n]];s.splice(0,i)}}))}function getTickMarkLength(t){return t.drawTicks?t.tickLength:0}function getTitleHeight(t,e){if(!t.display)return 0;const s=E(t.font,e);const i=R(t.padding);const n=a(t.text)?t.text.length:1;return n*s.lineHeight+i.height}function createScaleContext(t,e){return c(t,{scale:e,type:"scale"})}function createTickContext(t,e,s){return c(t,{tick:s,index:e,type:"tick"})}function titleAlign(t,e,s){let i=I(t);(s&&"right"!==e||!s&&"right"===e)&&(i=reverseAlign(i));return i}function titleArgs(t,e,s,i){const{top:n,left:a,bottom:r,right:l,chart:c}=t;const{chartArea:h,scales:d}=c;let u=0;let g,f,p;const m=r-n;const x=l-a;if(t.isHorizontal()){f=B(i,a,l);if(o(s)){const t=Object.keys(s)[0];const i=s[t];p=d[t].getPixelForValue(i)+m-e}else p="center"===s?(h.bottom+h.top)/2+m-e:offsetFromEdge(t,s,e);g=l-a}else{if(o(s)){const t=Object.keys(s)[0];const i=s[t];f=d[t].getPixelForValue(i)-x+e}else f="center"===s?(h.left+h.right)/2-x+e:offsetFromEdge(t,s,e);p=B(i,r,n);u="left"===s?-y:y}return{titleX:f,titleY:p,maxWidth:g,rotation:u}}class Scale extends Element{constructor(t){super();this.id=t.id;this.type=t.type;this.options=void 0;this.ctx=t.ctx;this.chart=t.chart;this.top=void 0;this.bottom=void 0;this.left=void 0;this.right=void 0;this.width=void 0;this.height=void 0;this._margins={left:0,right:0,top:0,bottom:0};this.maxWidth=void 0;this.maxHeight=void 0;this.paddingTop=void 0;this.paddingBottom=void 0;this.paddingLeft=void 0;this.paddingRight=void 0;this.axis=void 0;this.labelRotation=void 0;this.min=void 0;this.max=void 0;this._range=void 0;this.ticks=[];this._gridLineItems=null;this._labelItems=null;this._labelSizes=null;this._length=0;this._maxLength=0;this._longestTextCache={};this._startPixel=void 0;this._endPixel=void 0;this._reversePixels=false;this._userMax=void 0;this._userMin=void 0;this._suggestedMax=void 0;this._suggestedMin=void 0;this._ticksLength=0;this._borderValue=0;this._cache={};this._dataLimitsCached=false;this.$context=void 0}init(t){this.options=t.setContext(this.getContext());this.axis=t.axis;this._userMin=this.parse(t.min);this._userMax=this.parse(t.max);this._suggestedMin=this.parse(t.suggestedMin);this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:s,_suggestedMax:i}=this;t=F(t,Number.POSITIVE_INFINITY);e=F(e,Number.NEGATIVE_INFINITY);s=F(s,Number.POSITIVE_INFINITY);i=F(i,Number.NEGATIVE_INFINITY);return{min:F(t,s),max:F(e,i),minDefined:r(t),maxDefined:r(e)}}getMinMax(t){let{min:e,max:s,minDefined:i,maxDefined:n}=this.getUserBounds();let o;if(i&&n)return{min:e,max:s};const a=this.getMatchingVisibleMetas();for(let r=0,l=a.length;r<l;++r){o=a[r].controller.getMinMax(this,t);i||(e=Math.min(e,o.min));n||(s=Math.max(s,o.max))}e=n&&e>s?s:e;s=i&&e>s?e:s;return{min:F(e,F(s,e)),max:F(s,F(e,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}beforeLayout(){this._cache={};this._dataLimitsCached=false}beforeUpdate(){z(this.options.beforeUpdate,[this])}update(t,e,s){const{beginAtZero:i,grace:n,ticks:o}=this.options;const a=o.sampleSize;this.beforeUpdate();this.maxWidth=t;this.maxHeight=e;this._margins=s=Object.assign({left:0,right:0,top:0,bottom:0},s);this.ticks=null;this._labelSizes=null;this._gridLineItems=null;this._labelItems=null;this.beforeSetDimensions();this.setDimensions();this.afterSetDimensions();this._maxLength=this.isHorizontal()?this.width+s.left+s.right:this.height+s.top+s.bottom;if(!this._dataLimitsCached){this.beforeDataLimits();this.determineDataLimits();this.afterDataLimits();this._range=V(this,n,i);this._dataLimitsCached=true}this.beforeBuildTicks();this.ticks=this.buildTicks()||[];this.afterBuildTicks();const r=a<this.ticks.length;this._convertTicksToLabels(r?sample(this.ticks,a):this.ticks);this.configure();this.beforeCalculateLabelRotation();this.calculateLabelRotation();this.afterCalculateLabelRotation();if(o.display&&(o.autoSkip||"auto"===o.source)){this.ticks=autoSkip(this,this.ticks);this._labelSizes=null;this.afterAutoSkip()}r&&this._convertTicksToLabels(this.ticks);this.beforeFit();this.fit();this.afterFit();this.afterUpdate()}configure(){let t=this.options.reverse;let e,s;if(this.isHorizontal()){e=this.left;s=this.right}else{e=this.top;s=this.bottom;t=!t}this._startPixel=e;this._endPixel=s;this._reversePixels=t;this._length=s-e;this._alignToPixels=this.options.alignToPixels}afterUpdate(){z(this.options.afterUpdate,[this])}beforeSetDimensions(){z(this.options.beforeSetDimensions,[this])}setDimensions(){if(this.isHorizontal()){this.width=this.maxWidth;this.left=0;this.right=this.width}else{this.height=this.maxHeight;this.top=0;this.bottom=this.height}this.paddingLeft=0;this.paddingTop=0;this.paddingRight=0;this.paddingBottom=0}afterSetDimensions(){z(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext());z(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){z(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let s,i,n;for(s=0,i=t.length;s<i;s++){n=t[s];n.label=z(e.callback,[n.value,s,t],this)}}afterTickToLabelConversion(){z(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){z(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options;const e=t.ticks;const s=this.ticks.length;const i=e.minRotation||0;const n=e.maxRotation;let o=i;let a,r,l;if(!this._isVisible()||!e.display||i>=n||s<=1||!this.isHorizontal()){this.labelRotation=i;return}const c=this._getLabelSizes();const h=c.widest.width;const d=c.highest.height;const u=N(this.chart.width-h,0,this.maxWidth);a=t.offset?this.maxWidth/s:u/(s-1);if(h+6>a){a=u/(s-(t.offset?.5:1));r=this.maxHeight-getTickMarkLength(t.grid)-e.padding-getTitleHeight(t.title,this.chart.options.font);l=Math.sqrt(h*h+d*d);o=W(Math.min(Math.asin(N((c.highest.height+6)/a,-1,1)),Math.asin(N(r/l,-1,1))-Math.asin(N(d/l,-1,1))));o=Math.max(i,Math.min(n,o))}this.labelRotation=o}afterCalculateLabelRotation(){z(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){z(this.options.beforeFit,[this])}fit(){const t={width:0,height:0};const{chart:e,options:{ticks:s,title:i,grid:n}}=this;const o=this._isVisible();const a=this.isHorizontal();if(o){const o=getTitleHeight(i,e.options.font);if(a){t.width=this.maxWidth;t.height=getTickMarkLength(n)+o}else{t.height=this.maxHeight;t.width=getTickMarkLength(n)+o}if(s.display&&this.ticks.length){const{first:e,last:i,widest:n,highest:o}=this._getLabelSizes();const r=2*s.padding;const l=k(this.labelRotation);const c=Math.cos(l);const h=Math.sin(l);if(a){const e=s.mirror?0:h*n.width+c*o.height;t.height=Math.min(this.maxHeight,t.height+e+r)}else{const e=s.mirror?0:c*n.width+h*o.height;t.width=Math.min(this.maxWidth,t.width+e+r)}this._calculatePadding(e,i,h,c)}}this._handleMargins();if(a){this.width=this._length=e.width-this._margins.left-this._margins.right;this.height=t.height}else{this.width=t.width;this.height=this._length=e.height-this._margins.top-this._margins.bottom}}_calculatePadding(t,e,s,i){const{ticks:{align:n,padding:o},position:a}=this.options;const r=0!==this.labelRotation;const l="top"!==a&&"x"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left;const c=this.right-this.getPixelForTick(this.ticks.length-1);let h=0;let d=0;if(r)if(l){h=i*t.width;d=s*e.height}else{h=s*t.height;d=i*e.width}else if("start"===n)d=e.width;else if("end"===n)h=t.width;else if("inner"!==n){h=t.width/2;d=e.width/2}this.paddingLeft=Math.max((h-a+o)*this.width/(this.width-a),0);this.paddingRight=Math.max((d-c+o)*this.width/(this.width-c),0)}else{let s=e.height/2;let i=t.height/2;if("start"===n){s=0;i=t.height}else if("end"===n){s=e.height;i=0}this.paddingTop=s+o;this.paddingBottom=i+o}}_handleMargins(){if(this._margins){this._margins.left=Math.max(this.paddingLeft,this._margins.left);this._margins.top=Math.max(this.paddingTop,this._margins.top);this._margins.right=Math.max(this.paddingRight,this._margins.right);this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom)}}afterFit(){z(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return"top"===e||"bottom"===e||"x"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){this.beforeTickToLabelConversion();this.generateTickLabels(t);let e,s;for(e=0,s=t.length;e<s;e++)if(x(t[e].label)){t.splice(e,1);s--;e--}this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let s=this.ticks;e<s.length&&(s=sample(s,e));this._labelSizes=t=this._computeLabelSizes(s,s.length)}return t}_computeLabelSizes(t,e){const{ctx:s,_longestTextCache:i}=this;const n=[];const o=[];let r=0;let l=0;let c,h,d,u,g,f,p,m,b,_,y;for(c=0;c<e;++c){u=t[c].label;g=this._resolveTickFontOptions(c);s.font=f=g.string;p=i[f]=i[f]||{data:{},gc:[]};m=g.lineHeight;b=_=0;if(x(u)||a(u)){if(a(u))for(h=0,d=u.length;h<d;++h){y=u[h];if(!x(y)&&!a(y)){b=H(s,p.data,p.gc,b,y);_+=m}}}else{b=H(s,p.data,p.gc,b,u);_=m}n.push(b);o.push(_);r=Math.max(b,r);l=Math.max(_,l)}garbageCollect(i,e);const v=n.indexOf(r);const k=o.indexOf(l);const valueAt=t=>({width:n[t]||0,height:o[t]||0});return{first:valueAt(0),last:valueAt(e-1),widest:valueAt(v),highest:valueAt(k),widths:n,heights:o}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return j(this._alignToPixels?$(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const s=e[t];return s.$context||(s.$context=createTickContext(this.getContext(),t,s))}return this.$context||(this.$context=createScaleContext(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks;const e=k(this.labelRotation);const s=Math.abs(Math.cos(e));const i=Math.abs(Math.sin(e));const n=this._getLabelSizes();const o=t.autoSkipPadding||0;const a=n?n.widest.width+o:0;const r=n?n.highest.height+o:0;return this.isHorizontal()?r*s>a*i?a/s:r/i:r*i<a*s?r/s:a/i}_isVisible(){const t=this.options.display;return"auto"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis;const s=this.chart;const i=this.options;const{grid:n,position:a}=i;const r=n.offset;const l=this.isHorizontal();const c=this.ticks;const d=c.length+(r?1:0);const u=getTickMarkLength(n);const g=[];const f=n.setContext(this.getContext());const p=f.drawBorder?f.borderWidth:0;const m=p/2;const alignBorderValue=function(t){return $(s,t,p)};let x,b,_,y;let v,k,M,S,w,C,D,P;if("top"===a){x=alignBorderValue(this.bottom);k=this.bottom-u;S=x-m;C=alignBorderValue(t.top)+m;P=t.bottom}else if("bottom"===a){x=alignBorderValue(this.top);C=t.top;P=alignBorderValue(t.bottom)-m;k=x+m;S=this.top+u}else if("left"===a){x=alignBorderValue(this.right);v=this.right-u;M=x-m;w=alignBorderValue(t.left)+m;D=t.right}else if("right"===a){x=alignBorderValue(this.left);w=t.left;D=alignBorderValue(t.right)-m;v=x+m;M=this.left+u}else if("x"===e){if("center"===a)x=alignBorderValue((t.top+t.bottom)/2+.5);else if(o(a)){const t=Object.keys(a)[0];const e=a[t];x=alignBorderValue(this.chart.scales[t].getPixelForValue(e))}C=t.top;P=t.bottom;k=x+m;S=k+u}else if("y"===e){if("center"===a)x=alignBorderValue((t.left+t.right)/2);else if(o(a)){const t=Object.keys(a)[0];const e=a[t];x=alignBorderValue(this.chart.scales[t].getPixelForValue(e))}v=x-m;M=v-u;w=t.left;D=t.right}const A=h(i.ticks.maxTicksLimit,d);const L=Math.max(1,Math.ceil(d/A));for(b=0;b<d;b+=L){const t=n.setContext(this.getContext(b));const e=t.lineWidth;const i=t.color;const o=t.borderDash||[];const a=t.borderDashOffset;const c=t.tickWidth;const h=t.tickColor;const d=t.tickBorderDash||[];const u=t.tickBorderDashOffset;_=getPixelForGridLine(this,b,r);if(void 0!==_){y=$(s,_,e);l?v=M=w=D=y:k=S=C=P=y;g.push({tx1:v,ty1:k,tx2:M,ty2:S,x1:w,y1:C,x2:D,y2:P,width:e,color:i,borderDash:o,borderDashOffset:a,tickWidth:c,tickColor:h,tickBorderDash:d,tickBorderDashOffset:u})}}this._ticksLength=d;this._borderValue=x;return g}_computeLabelItems(t){const e=this.axis;const s=this.options;const{position:i,ticks:n}=s;const r=this.isHorizontal();const l=this.ticks;const{align:c,crossAlign:h,padding:d,mirror:u}=n;const g=getTickMarkLength(s.grid);const f=g+d;const p=u?-d:f;const m=-k(this.labelRotation);const x=[];let b,_,y,v,M,S,w,C,D,P,A,L;let T="middle";if("top"===i){S=this.bottom-p;w=this._getXAxisLabelAlignment()}else if("bottom"===i){S=this.top+p;w=this._getXAxisLabelAlignment()}else if("left"===i){const t=this._getYAxisLabelAlignment(g);w=t.textAlign;M=t.x}else if("right"===i){const t=this._getYAxisLabelAlignment(g);w=t.textAlign;M=t.x}else if("x"===e){if("center"===i)S=(t.top+t.bottom)/2+f;else if(o(i)){const t=Object.keys(i)[0];const e=i[t];S=this.chart.scales[t].getPixelForValue(e)+f}w=this._getXAxisLabelAlignment()}else if("y"===e){if("center"===i)M=(t.left+t.right)/2-f;else if(o(i)){const t=Object.keys(i)[0];const e=i[t];M=this.chart.scales[t].getPixelForValue(e)}w=this._getYAxisLabelAlignment(g).textAlign}"y"===e&&("start"===c?T="top":"end"===c&&(T="bottom"));const O=this._getLabelSizes();for(b=0,_=l.length;b<_;++b){y=l[b];v=y.label;const t=n.setContext(this.getContext(b));C=this.getPixelForTick(b)+n.labelOffset;D=this._resolveTickFontOptions(b);P=D.lineHeight;A=a(v)?v.length:1;const e=A/2;const s=t.color;const o=t.textStrokeColor;const c=t.textStrokeWidth;let d=w;if(r){M=C;"inner"===w&&(d=b===_-1?this.options.reverse?"left":"right":0===b?this.options.reverse?"right":"left":"center");L="top"===i?"near"===h||0!==m?-A*P+P/2:"center"===h?-O.highest.height/2-e*P+P:-O.highest.height+P/2:"near"===h||0!==m?P/2:"center"===h?O.highest.height/2-e*P:O.highest.height-A*P;u&&(L*=-1)}else{S=C;L=(1-A)*P/2}let g;if(t.showLabelBackdrop){const e=R(t.backdropPadding);const s=O.heights[b];const i=O.widths[b];let n=S+L-e.top;let o=M-e.left;switch(T){case"middle":n-=s/2;break;case"bottom":n-=s;break}switch(w){case"center":o-=i/2;break;case"right":o-=i;break}g={left:o,top:n,width:i+e.width,height:s+e.height,color:t.backdropColor}}x.push({rotation:m,label:v,font:D,color:s,strokeColor:o,strokeWidth:c,textOffset:L,textAlign:d,textBaseline:T,translation:[M,S],backdrop:g})}return x}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;const s=-k(this.labelRotation);if(s)return"top"===t?"left":"right";let i="center";"start"===e.align?i="left":"end"===e.align?i="right":"inner"===e.align&&(i="inner");return i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:s,mirror:i,padding:n}}=this.options;const o=this._getLabelSizes();const a=t+n;const r=o.widest.width;let l;let c;if("left"===e)if(i){c=this.right+n;if("near"===s)l="left";else if("center"===s){l="center";c+=r/2}else{l="right";c+=r}}else{c=this.right-a;if("near"===s)l="right";else if("center"===s){l="center";c-=r/2}else{l="left";c=this.left}}else if("right"===e)if(i){c=this.left+n;if("near"===s)l="right";else if("center"===s){l="center";c-=r/2}else{l="left";c-=r}}else{c=this.left+a;if("near"===s)l="left";else if("center"===s){l="center";c+=r/2}else{l="right";c=this.right}}else l="right";return{textAlign:l,x:c}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart;const e=this.options.position;return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:s,top:i,width:n,height:o}=this;if(e){t.save();t.fillStyle=e;t.fillRect(s,i,n,o);t.restore()}}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const s=this.ticks;const i=s.findIndex((e=>e.value===t));if(i>=0){const t=e.setContext(this.getContext(i));return t.lineWidth}return 0}drawGrid(t){const e=this.options.grid;const s=this.ctx;const i=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let n,o;const drawLine=(t,e,i)=>{if(i.width&&i.color){s.save();s.lineWidth=i.width;s.strokeStyle=i.color;s.setLineDash(i.borderDash||[]);s.lineDashOffset=i.borderDashOffset;s.beginPath();s.moveTo(t.x,t.y);s.lineTo(e.x,e.y);s.stroke();s.restore()}};if(e.display)for(n=0,o=i.length;n<o;++n){const t=i[n];e.drawOnChartArea&&drawLine({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t);e.drawTicks&&drawLine({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{grid:s}}=this;const i=s.setContext(this.getContext());const n=s.drawBorder?i.borderWidth:0;if(!n)return;const o=s.setContext(this.getContext(0)).lineWidth;const a=this._borderValue;let r,l,c,h;if(this.isHorizontal()){r=$(t,this.left,n)-n/2;l=$(t,this.right,o)+o/2;c=h=a}else{c=$(t,this.top,n)-n/2;h=$(t,this.bottom,o)+o/2;r=l=a}e.save();e.lineWidth=i.borderWidth;e.strokeStyle=i.borderColor;e.beginPath();e.moveTo(r,c);e.lineTo(l,h);e.stroke();e.restore()}drawLabels(t){const e=this.options.ticks;if(!e.display)return;const s=this.ctx;const i=this._computeLabelArea();i&&U(s,i);const n=this._labelItems||(this._labelItems=this._computeLabelItems(t));let o,a;for(o=0,a=n.length;o<a;++o){const t=n[o];const e=t.font;const i=t.label;if(t.backdrop){s.fillStyle=t.backdrop.color;s.fillRect(t.backdrop.left,t.backdrop.top,t.backdrop.width,t.backdrop.height)}let a=t.textOffset;Y(s,i,0,a,e,t)}i&&X(s)}drawTitle(){const{ctx:t,options:{position:e,title:s,reverse:i}}=this;if(!s.display)return;const n=E(s.font);const r=R(s.padding);const l=s.align;let c=n.lineHeight/2;if("bottom"===e||"center"===e||o(e)){c+=r.bottom;a(s.text)&&(c+=n.lineHeight*(s.text.length-1))}else c+=r.top;const{titleX:h,titleY:d,maxWidth:u,rotation:g}=titleArgs(this,c,e,l);Y(t,s.text,0,0,n,{color:s.color,maxWidth:u,rotation:g,textAlign:titleAlign(l,e,i),textBaseline:"middle",translation:[h,d]})}draw(t){if(this._isVisible()){this.drawBackground();this.drawGrid(t);this.drawBorder();this.drawTitle();this.drawLabels(t)}}_layers(){const t=this.options;const e=t.ticks&&t.ticks.z||0;const s=h(t.grid&&t.grid.z,-1);return this._isVisible()&&this.draw===Scale.prototype.draw?[{z:s,draw:t=>{this.drawBackground();this.drawGrid(t);this.drawTitle()}},{z:s+1,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas();const s=this.axis+"AxisID";const i=[];let n,o;for(n=0,o=e.length;n<o;++n){const o=e[n];o[s]!==this.id||t&&o.type!==t||i.push(o)}return i}_resolveTickFontOptions(t){const e=this.options.ticks.setContext(this.getContext(t));return E(e.font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class TypedRegistry{constructor(t,e,s){this.type=t;this.scope=e;this.override=s;this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let s;isIChartComponent(e)&&(s=this.register(e));const i=this.items;const o=t.id;const a=this.scope+"."+o;if(!o)throw new Error("class does not have id: "+t);if(o in i)return a;i[o]=t;registerDefaults(t,a,s);this.override&&n.override(t.id,t.overrides);return a}get(t){return this.items[t]}unregister(t){const e=this.items;const s=t.id;const i=this.scope;s in e&&delete e[s];if(i&&s in n[i]){delete n[i][s];this.override&&delete K[s]}}}function registerDefaults(t,e,s){const i=G(Object.create(null),[s?n.get(s):{},n.get(e),t.defaults]);n.set(e,i);t.defaultRoutes&&routeDefaults(e,t.defaultRoutes);t.descriptors&&n.describe(e,t.descriptors)}function routeDefaults(t,e){Object.keys(e).forEach((s=>{const i=s.split(".");const o=i.pop();const a=[t].concat(i).join(".");const r=e[s].split(".");const l=r.pop();const c=r.join(".");n.route(a,o,c,l)}))}function isIChartComponent(t){return"id"in t&&"defaults"in t}class Registry{constructor(){this.controllers=new TypedRegistry(DatasetController,"datasets",true);this.elements=new TypedRegistry(Element,"elements");this.plugins=new TypedRegistry(Object,"plugins");this.scales=new TypedRegistry(Scale,"scales");this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,s){[...e].forEach((e=>{const i=s||this._getRegistryForType(e);s||i.isForType(e)||i===this.plugins&&e.id?this._exec(t,i,e):O(e,(e=>{const i=s||this._getRegistryForType(e);this._exec(t,i,e)}))}))}_exec(t,e,s){const i=q(t);z(s["before"+i],[],s);e[t](s);z(s["after"+i],[],s)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const s=this._typedRegistries[e];if(s.isForType(t))return s}return this.plugins}_get(t,e,s){const i=e.get(t);if(void 0===i)throw new Error('"'+t+'" is not a registered '+s+".");return i}}var ae=new Registry;class ScatterController extends DatasetController{update(t){const e=this._cachedMeta;const{data:s=[]}=e;const i=this.chart._animationsDisabled;let{start:n,count:o}=C(e,s,i);this._drawStart=n;this._drawCount=o;if(D(e)){n=0;o=s.length}if(this.options.showLine){const{dataset:n,_dataset:o}=e;n._chart=this.chart;n._datasetIndex=this.index;n._decimated=!!o._decimated;n.points=s;const a=this.resolveDatasetElementOptions(t);a.segment=this.options.segment;this.updateElement(n,void 0,{animated:!i,options:a},t)}this.updateElements(s,n,o,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=ae.getElement("line"));super.addElements()}updateElements(t,e,s,i){const n="reset"===i;const{iScale:o,vScale:a,_stacked:r,_dataset:l}=this._cachedMeta;const c=this.resolveDataElementOptions(e,i);const h=this.getSharedOptions(c);const d=this.includeOptions(i,h);const u=o.axis;const g=a.axis;const{spanGaps:f,segment:p}=this.options;const m=P(f)?f:Number.POSITIVE_INFINITY;const b=this.chart._animationsDisabled||n||"none"===i;let _=e>0&&this.getParsed(e-1);for(let c=e;c<e+s;++c){const e=t[c];const s=this.getParsed(c);const f=b?e:{};const y=x(s[g]);const v=f[u]=o.getPixelForValue(s[u],c);const k=f[g]=n||y?a.getBasePixel():a.getPixelForValue(r?this.applyStack(a,s,r):s[g],c);f.skip=isNaN(v)||isNaN(k)||y;f.stop=c>0&&Math.abs(s[u]-_[u])>m;if(p){f.parsed=s;f.raw=l.data[c]}d&&(f.options=h||this.resolveDataElementOptions(c,e.active?"active":i));b||this.updateElement(e,c,f,i);_=s}this.updateSharedOptions(h,i,c)}getMaxOverflow(){const t=this._cachedMeta;const e=t.data||[];if(!this.options.showLine){let t=0;for(let s=e.length-1;s>=0;--s)t=Math.max(t,e[s].size(this.resolveDataElementOptions(s))/2);return t>0&&t}const s=t.dataset;const i=s.options&&s.options.borderWidth||0;if(!e.length)return i;const n=e[0].size(this.resolveDataElementOptions(0));const o=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(i,n,o)/2}}ScatterController.id="scatter";ScatterController.defaults={datasetElementType:false,dataElementType:"point",showLine:false,fill:false};ScatterController.overrides={interaction:{mode:"point"},plugins:{tooltip:{callbacks:{title(){return""},label(t){return"("+t.label+", "+t.formattedValue+")"}}}},scales:{x:{type:"linear"},y:{type:"linear"}}};var re=Object.freeze({__proto__:null,BarController:BarController,BubbleController:BubbleController,DoughnutController:DoughnutController,LineController:LineController,PolarAreaController:PolarAreaController,PieController:PieController,RadarController:RadarController,ScatterController:ScatterController});function abstract(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class DateAdapter{constructor(t){this.options=t||{}}init(t){}formats(){return abstract()}parse(t,e){return abstract()}format(t,e){return abstract()}add(t,e,s){return abstract()}diff(t,e,s){return abstract()}startOf(t,e,s){return abstract()}endOf(t,e){return abstract()}}DateAdapter.override=function(t){Object.assign(DateAdapter.prototype,t)};var le={_date:DateAdapter};function binarySearch(t,e,s,i){const{controller:n,data:o,_sorted:a}=t;const r=n._cachedMeta.iScale;if(r&&e===r.axis&&"r"!==e&&a&&o.length){const t=r._reversePixels?J:Z;if(!i)return t(o,e,s);if(n._sharedOptions){const i=o[0];const n="function"===typeof i.getRange&&i.getRange(e);if(n){const i=t(o,e,s-n);const a=t(o,e,s+n);return{lo:i.lo,hi:a.hi}}}}return{lo:0,hi:o.length-1}}function evaluateInteractionItems(t,e,s,i,n){const o=t.getSortedVisibleDatasetMetas();const a=s[e];for(let t=0,s=o.length;t<s;++t){const{index:s,data:r}=o[t];const{lo:l,hi:c}=binarySearch(o[t],e,a,n);for(let t=l;t<=c;++t){const e=r[t];e.skip||i(e,s,t)}}}function getDistanceMetricForAxis(t){const e=-1!==t.indexOf("x");const s=-1!==t.indexOf("y");return function(t,i){const n=e?Math.abs(t.x-i.x):0;const o=s?Math.abs(t.y-i.y):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}}function getIntersectItems(t,e,s,i,n){const o=[];if(!n&&!t.isPointInArea(e))return o;const evaluationFunc=function(s,a,r){(n||Q(s,t.chartArea,0))&&s.inRange(e.x,e.y,i)&&o.push({element:s,datasetIndex:a,index:r})};evaluateInteractionItems(t,s,e,evaluationFunc,true);return o}function getNearestRadialItems(t,e,s,i){let n=[];function evaluationFunc(t,s,o){const{startAngle:a,endAngle:r}=t.getProps(["startAngle","endAngle"],i);const{angle:l}=tt(t,{x:e.x,y:e.y});_(l,a,r)&&n.push({element:t,datasetIndex:s,index:o})}evaluateInteractionItems(t,s,e,evaluationFunc);return n}function getNearestCartesianItems(t,e,s,i,n,o){let a=[];const r=getDistanceMetricForAxis(s);let l=Number.POSITIVE_INFINITY;function evaluationFunc(s,c,h){const d=s.inRange(e.x,e.y,n);if(i&&!d)return;const u=s.getCenterPoint(n);const g=!!o||t.isPointInArea(u);if(!g&&!d)return;const f=r(e,u);if(f<l){a=[{element:s,datasetIndex:c,index:h}];l=f}else f===l&&a.push({element:s,datasetIndex:c,index:h})}evaluateInteractionItems(t,s,e,evaluationFunc);return a}function getNearestItems(t,e,s,i,n,o){return o||t.isPointInArea(e)?"r"!==s||i?getNearestCartesianItems(t,e,s,i,n,o):getNearestRadialItems(t,e,s,n):[]}function getAxisItems(t,e,s,i,n){const o=[];const a="x"===s?"inXRange":"inYRange";let r=false;evaluateInteractionItems(t,s,e,((t,i,l)=>{if(t[a](e[s],n)){o.push({element:t,datasetIndex:i,index:l});r=r||t.inRange(e.x,e.y,n)}}));return i&&!r?[]:o}var ce={evaluateInteractionItems:evaluateInteractionItems,modes:{index(t,e,s,i){const n=et(e,t);const o=s.axis||"x";const a=s.includeInvisible||false;const r=s.intersect?getIntersectItems(t,n,o,i,a):getNearestItems(t,n,o,false,i,a);const l=[];if(!r.length)return[];t.getSortedVisibleDatasetMetas().forEach((t=>{const e=r[0].index;const s=t.data[e];s&&!s.skip&&l.push({element:s,datasetIndex:t.index,index:e})}));return l},dataset(t,e,s,i){const n=et(e,t);const o=s.axis||"xy";const a=s.includeInvisible||false;let r=s.intersect?getIntersectItems(t,n,o,i,a):getNearestItems(t,n,o,false,i,a);if(r.length>0){const e=r[0].datasetIndex;const s=t.getDatasetMeta(e).data;r=[];for(let t=0;t<s.length;++t)r.push({element:s[t],datasetIndex:e,index:t})}return r},point(t,e,s,i){const n=et(e,t);const o=s.axis||"xy";const a=s.includeInvisible||false;return getIntersectItems(t,n,o,i,a)},nearest(t,e,s,i){const n=et(e,t);const o=s.axis||"xy";const a=s.includeInvisible||false;return getNearestItems(t,n,o,s.intersect,i,a)},x(t,e,s,i){const n=et(e,t);return getAxisItems(t,n,"x",s.intersect,i)},y(t,e,s,i){const n=et(e,t);return getAxisItems(t,n,"y",s.intersect,i)}}};const he=["left","top","right","bottom"];function filterByPosition(t,e){return t.filter((t=>t.pos===e))}function filterDynamicPositionByAxis(t,e){return t.filter((t=>-1===he.indexOf(t.pos)&&t.box.axis===e))}function sortByWeight(t,e){return t.sort(((t,s)=>{const i=e?s:t;const n=e?t:s;return i.weight===n.weight?i.index-n.index:i.weight-n.weight}))}function wrapBoxes(t){const e=[];let s,i,n,o,a,r;for(s=0,i=(t||[]).length;s<i;++s){n=t[s];({position:o,options:{stack:a,stackWeight:r=1}}=n);e.push({index:s,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&&o+a,stackWeight:r})}return e}function buildStacks(t){const e={};for(const s of t){const{stack:t,pos:i,stackWeight:n}=s;if(!t||!he.includes(i))continue;const o=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});o.count++;o.weight+=n}return e}function setLayoutDims(t,e){const s=buildStacks(t);const{vBoxMaxWidth:i,hBoxMaxHeight:n}=e;let o,a,r;for(o=0,a=t.length;o<a;++o){r=t[o];const{fullSize:a}=r.box;const l=s[r.stack];const c=l&&r.stackWeight/l.weight;if(r.horizontal){r.width=c?c*i:a&&e.availableWidth;r.height=n}else{r.width=i;r.height=c?c*n:a&&e.availableHeight}}return s}function buildLayoutBoxes(t){const e=wrapBoxes(t);const s=sortByWeight(e.filter((t=>t.box.fullSize)),true);const i=sortByWeight(filterByPosition(e,"left"),true);const n=sortByWeight(filterByPosition(e,"right"));const o=sortByWeight(filterByPosition(e,"top"),true);const a=sortByWeight(filterByPosition(e,"bottom"));const r=filterDynamicPositionByAxis(e,"x");const l=filterDynamicPositionByAxis(e,"y");return{fullSize:s,leftAndTop:i.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:filterByPosition(e,"chartArea"),vertical:i.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}function getCombinedMax(t,e,s,i){return Math.max(t[s],e[s])+Math.max(t[i],e[i])}function updateMaxPadding(t,e){t.top=Math.max(t.top,e.top);t.left=Math.max(t.left,e.left);t.bottom=Math.max(t.bottom,e.bottom);t.right=Math.max(t.right,e.right)}function updateDims(t,e,s,i){const{pos:n,box:a}=s;const r=t.maxPadding;if(!o(n)){s.size&&(t[n]-=s.size);const e=i[s.stack]||{size:0,count:1};e.size=Math.max(e.size,s.horizontal?a.height:a.width);s.size=e.size/e.count;t[n]+=s.size}a.getPadding&&updateMaxPadding(r,a.getPadding());const l=Math.max(0,e.outerWidth-getCombinedMax(r,t,"left","right"));const c=Math.max(0,e.outerHeight-getCombinedMax(r,t,"top","bottom"));const h=l!==t.w;const d=c!==t.h;t.w=l;t.h=c;return s.horizontal?{same:h,other:d}:{same:d,other:h}}function handleMaxPadding(t){const e=t.maxPadding;function updatePos(s){const i=Math.max(e[s]-t[s],0);t[s]+=i;return i}t.y+=updatePos("top");t.x+=updatePos("left");updatePos("right");updatePos("bottom")}function getMargins(t,e){const s=e.maxPadding;function marginForPositions(t){const i={left:0,top:0,right:0,bottom:0};t.forEach((t=>{i[t]=Math.max(e[t],s[t])}));return i}return marginForPositions(t?["left","right"]:["top","bottom"])}function fitBoxes(t,e,s,i){const n=[];let o,a,r,l,c,h;for(o=0,a=t.length,c=0;o<a;++o){r=t[o];l=r.box;l.update(r.width||e.w,r.height||e.h,getMargins(r.horizontal,e));const{same:a,other:d}=updateDims(e,s,r,i);c|=a&&n.length;h=h||d;l.fullSize||n.push(r)}return c&&fitBoxes(n,e,s,i)||h}function setBoxDims(t,e,s,i,n){t.top=s;t.left=e;t.right=e+i;t.bottom=s+n;t.width=i;t.height=n}function placeBoxes(t,e,s,i){const n=s.padding;let{x:o,y:a}=e;for(const r of t){const t=r.box;const l=i[r.stack]||{count:1,placed:0,weight:1};const c=r.stackWeight/l.weight||1;if(r.horizontal){const i=e.w*c;const o=l.size||t.height;p(l.start)&&(a=l.start);t.fullSize?setBoxDims(t,n.left,a,s.outerWidth-n.right-n.left,o):setBoxDims(t,e.left+l.placed,a,i,o);l.start=a;l.placed+=i;a=t.bottom}else{const i=e.h*c;const a=l.size||t.width;p(l.start)&&(o=l.start);t.fullSize?setBoxDims(t,o,n.top,a,s.outerHeight-n.bottom-n.top):setBoxDims(t,o,e.top+l.placed,a,i);l.start=o;l.placed+=i;o=t.right}}e.x=o;e.y=a}n.set("layout",{autoPadding:true,padding:{top:0,right:0,bottom:0,left:0}});var de={addBox(t,e){t.boxes||(t.boxes=[]);e.fullSize=e.fullSize||false;e.position=e.position||"top";e.weight=e.weight||0;e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]};t.boxes.push(e)},removeBox(t,e){const s=t.boxes?t.boxes.indexOf(e):-1;-1!==s&&t.boxes.splice(s,1)},configure(t,e,s){e.fullSize=s.fullSize;e.position=s.position;e.weight=s.weight},update(t,e,s,i){if(!t)return;const n=R(t.options.layout.padding);const o=Math.max(e-n.width,0);const a=Math.max(s-n.height,0);const r=buildLayoutBoxes(t.boxes);const l=r.vertical;const c=r.horizontal;O(t.boxes,(t=>{"function"===typeof t.beforeLayout&&t.beforeLayout()}));const h=l.reduce(((t,e)=>e.box.options&&false===e.box.options.display?t:t+1),0)||1;const d=Object.freeze({outerWidth:e,outerHeight:s,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/h,hBoxMaxHeight:a/2});const u=Object.assign({},n);updateMaxPadding(u,R(i));const g=Object.assign({maxPadding:u,w:o,h:a,x:n.left,y:n.top},n);const f=setLayoutDims(l.concat(c),d);fitBoxes(r.fullSize,g,d,f);fitBoxes(l,g,d,f);fitBoxes(c,g,d,f)&&fitBoxes(l,g,d,f);handleMaxPadding(g);placeBoxes(r.leftAndTop,g,d,f);g.x+=g.w;g.y+=g.h;placeBoxes(r.rightAndBottom,g,d,f);t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w};O(r.chartArea,(e=>{const s=e.box;Object.assign(s,t.chartArea);s.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}))}};class BasePlatform{acquireContext(t,e){}releaseContext(t){return false}addEventListener(t,e,s){}removeEventListener(t,e,s){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,s,i){e=Math.max(0,e||t.width);s=s||t.height;return{width:e,height:Math.max(0,i?Math.floor(e/i):s)}}isAttached(t){return true}updateConfig(t){}}class BasicPlatform extends BasePlatform{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=false}}const ue="$chartjs";const ge={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};const isNullOrEmpty=t=>null===t||""===t;function initCanvas(t,e){const s=t.style;const i=t.getAttribute("height");const n=t.getAttribute("width");t[ue]={initial:{height:i,width:n,style:{display:s.display,height:s.height,width:s.width}}};s.display=s.display||"block";s.boxSizing=s.boxSizing||"border-box";if(isNullOrEmpty(n)){const e=st(t,"width");void 0!==e&&(t.width=e)}if(isNullOrEmpty(i))if(""===t.style.height)t.height=t.width/(e||2);else{const e=st(t,"height");void 0!==e&&(t.height=e)}return t}const fe=!!it&&{passive:true};function addListener(t,e,s){t.addEventListener(e,s,fe)}function removeListener(t,e,s){t.canvas.removeEventListener(e,s,fe)}function fromNativeEvent(t,e){const s=ge[t.type]||t.type;const{x:i,y:n}=et(t,e);return{type:s,chart:e,native:t,x:void 0!==i?i:null,y:void 0!==n?n:null}}function nodeListContains(t,e){for(const s of t)if(s===e||s.contains(e))return true}function createAttachObserver(t,e,s){const i=t.canvas;const n=new MutationObserver((t=>{let e=false;for(const s of t){e=e||nodeListContains(s.addedNodes,i);e=e&&!nodeListContains(s.removedNodes,i)}e&&s()}));n.observe(document,{childList:true,subtree:true});return n}function createDetachObserver(t,e,s){const i=t.canvas;const n=new MutationObserver((t=>{let e=false;for(const s of t){e=e||nodeListContains(s.removedNodes,i);e=e&&!nodeListContains(s.addedNodes,i)}e&&s()}));n.observe(document,{childList:true,subtree:true});return n}const pe=new Map;let me=0;function onWindowResize(){const t=window.devicePixelRatio;if(t!==me){me=t;pe.forEach(((e,s)=>{s.currentDevicePixelRatio!==t&&e()}))}}function listenDevicePixelRatioChanges(t,e){pe.size||window.addEventListener("resize",onWindowResize);pe.set(t,e)}function unlistenDevicePixelRatioChanges(t){pe.delete(t);pe.size||window.removeEventListener("resize",onWindowResize)}function createResizeObserver(t,e,s){const i=t.canvas;const n=i&&nt(i);if(!n)return;const o=ot(((t,e)=>{const i=n.clientWidth;s(t,e);i<n.clientWidth&&s()}),window);const a=new ResizeObserver((t=>{const e=t[0];const s=e.contentRect.width;const i=e.contentRect.height;0===s&&0===i||o(s,i)}));a.observe(n);listenDevicePixelRatioChanges(t,o);return a}function releaseObserver(t,e,s){s&&s.disconnect();"resize"===e&&unlistenDevicePixelRatioChanges(t)}function createProxyAndListen(t,e,s){const i=t.canvas;const n=ot((e=>{null!==t.ctx&&s(fromNativeEvent(e,t))}),t,(t=>{const e=t[0];return[e,e.offsetX,e.offsetY]}));addListener(i,e,n);return n}class DomPlatform extends BasePlatform{acquireContext(t,e){const s=t&&t.getContext&&t.getContext("2d");if(s&&s.canvas===t){initCanvas(t,e);return s}return null}releaseContext(t){const e=t.canvas;if(!e[ue])return false;const s=e[ue].initial;["height","width"].forEach((t=>{const i=s[t];x(i)?e.removeAttribute(t):e.setAttribute(t,i)}));const i=s.style||{};Object.keys(i).forEach((t=>{e.style[t]=i[t]}));e.width=e.width;delete e[ue];return true}addEventListener(t,e,s){this.removeEventListener(t,e);const i=t.$proxies||(t.$proxies={});const n={attach:createAttachObserver,detach:createDetachObserver,resize:createResizeObserver};const o=n[e]||createProxyAndListen;i[e]=o(t,e,s)}removeEventListener(t,e){const s=t.$proxies||(t.$proxies={});const i=s[e];if(!i)return;const n={attach:releaseObserver,detach:releaseObserver,resize:releaseObserver};const o=n[e]||removeListener;o(t,e,i);s[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,s,i){return at(t,e,s,i)}isAttached(t){const e=nt(t);return!!(e&&e.isConnected)}}function _detectPlatform(t){return!rt()||"undefined"!==typeof OffscreenCanvas&&t instanceof OffscreenCanvas?BasicPlatform:DomPlatform}class PluginService{constructor(){this._init=[]}notify(t,e,s,i){if("beforeInit"===e){this._init=this._createDescriptors(t,true);this._notify(this._init,t,"install")}const n=i?this._descriptors(t).filter(i):this._descriptors(t);const o=this._notify(n,t,e,s);if("afterDestroy"===e){this._notify(n,t,"stop");this._notify(this._init,t,"uninstall")}return o}_notify(t,e,s,i){i=i||{};for(const n of t){const t=n.plugin;const o=t[s];const a=[e,i,n.options];if(false===z(o,a,t)&&i.cancelable)return false}return true}invalidate(){if(!x(this._cache)){this._oldCache=this._cache;this._cache=void 0}}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);this._notifyStateChanges(t);return e}_createDescriptors(t,e){const s=t&&t.config;const i=h(s.options&&s.options.plugins,{});const n=allPlugins(s);return false!==i||e?createDescriptors(t,n,i,e):[]}_notifyStateChanges(t){const e=this._oldCache||[];const s=this._cache;const diff=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(diff(e,s),t,"stop");this._notify(diff(s,e),t,"start")}}function allPlugins(t){const e={};const s=[];const i=Object.keys(ae.plugins.items);for(let t=0;t<i.length;t++)s.push(ae.getPlugin(i[t]));const n=t.plugins||[];for(let t=0;t<n.length;t++){const i=n[t];if(-1===s.indexOf(i)){s.push(i);e[i.id]=true}}return{plugins:s,localIds:e}}function getOpts(t,e){return e||false!==t?true===t?{}:t:null}function createDescriptors(t,{plugins:e,localIds:s},i,n){const o=[];const a=t.getContext();for(const r of e){const e=r.id;const l=getOpts(i[e],n);null!==l&&o.push({plugin:r,options:pluginOpts(t.config,{plugin:r,local:s[e]},l,a)})}return o}function pluginOpts(t,{plugin:e,local:s},i,n){const o=t.pluginScopeKeys(e);const a=t.getOptionScopes(i,o);s&&e.defaults&&a.push(e.defaults);return t.createResolver(a,n,[""],{scriptable:false,indexable:false,allKeys:true})}function getIndexAxis(t,e){const s=n.datasets[t]||{};const i=(e.datasets||{})[t]||{};return i.indexAxis||e.indexAxis||s.indexAxis||"x"}function getAxisFromDefaultScaleID(t,e){let s=t;"_index_"===t?s=e:"_value_"===t&&(s="x"===e?"y":"x");return s}function getDefaultScaleIDFromAxis(t,e){return t===e?"_index_":"_value_"}function axisFromPosition(t){return"top"===t||"bottom"===t?"x":"left"===t||"right"===t?"y":void 0}function determineAxis(t,e){return"x"===t||"y"===t?t:e.axis||axisFromPosition(e.position)||t.charAt(0).toLowerCase()}function mergeScaleConfig(t,e){const s=K[t.type]||{scales:{}};const i=e.scales||{};const a=getIndexAxis(t.type,e);const r=Object.create(null);const l=Object.create(null);Object.keys(i).forEach((t=>{const e=i[t];if(!o(e))return console.error(`Invalid scale configuration for scale: ${t}`);if(e._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${t}`);const n=determineAxis(t,e);const c=getDefaultScaleIDFromAxis(n,a);const h=s.scales||{};r[n]=r[n]||t;l[t]=lt(Object.create(null),[{axis:n},e,h[n],h[c]])}));t.data.datasets.forEach((s=>{const n=s.type||t.type;const o=s.indexAxis||getIndexAxis(n,e);const a=K[n]||{};const c=a.scales||{};Object.keys(c).forEach((t=>{const e=getAxisFromDefaultScaleID(t,o);const n=s[e+"AxisID"]||r[e]||e;l[n]=l[n]||Object.create(null);lt(l[n],[{axis:e},i[n],c[t]])}))}));Object.keys(l).forEach((t=>{const e=l[t];lt(e,[n.scales[e.type],n.scale])}));return l}function initOptions(t){const e=t.options||(t.options={});e.plugins=h(e.plugins,{});e.scales=mergeScaleConfig(t,e)}function initData(t){t=t||{};t.datasets=t.datasets||[];t.labels=t.labels||[];return t}function initConfig(t){t=t||{};t.data=initData(t.data);initOptions(t);return t}const xe=new Map;const be=new Set;function cachedKeys(t,e){let s=xe.get(t);if(!s){s=e();xe.set(t,s);be.add(s)}return s}const addIfFound=(t,e,s)=>{const i=f(e,s);void 0!==i&&t.add(i)};class Config{constructor(t){this._config=initConfig(t);this._scopeCache=new Map;this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=initData(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache();initOptions(t)}clearCache(){this._scopeCache.clear();this._resolverCache.clear()}datasetScopeKeys(t){return cachedKeys(t,(()=>[[`datasets.${t}`,""]]))}datasetAnimationScopeKeys(t,e){return cachedKeys(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]]))}datasetElementScopeKeys(t,e){return cachedKeys(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]]))}pluginScopeKeys(t){const e=t.id;const s=this.type;return cachedKeys(`${s}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const s=this._scopeCache;let i=s.get(t);if(!i||e){i=new Map;s.set(t,i)}return i}getOptionScopes(t,e,s){const{options:i,type:o}=this;const a=this._cachedScopes(t,s);const r=a.get(e);if(r)return r;const l=new Set;e.forEach((e=>{if(t){l.add(t);e.forEach((e=>addIfFound(l,t,e)))}e.forEach((t=>addIfFound(l,i,t)));e.forEach((t=>addIfFound(l,K[o]||{},t)));e.forEach((t=>addIfFound(l,n,t)));e.forEach((t=>addIfFound(l,ct,t)))}));const c=Array.from(l);0===c.length&&c.push(Object.create(null));be.has(e)&&a.set(e,c);return c}chartOptionScopes(){const{options:t,type:e}=this;return[t,K[e]||{},n.datasets[e]||{},{type:e},n,ct]}resolveNamedOptions(t,e,s,i=[""]){const n={$shared:true};const{resolver:o,subPrefixes:a}=getResolver(this._resolverCache,t,i);let r=o;if(needContext(o,e)){n.$shared=false;s=ht(s)?s():s;const e=this.createResolver(t,s,a);r=dt(o,s,e)}for(const t of e)n[t]=r[t];return n}createResolver(t,e,s=[""],i){const{resolver:n}=getResolver(this._resolverCache,t,s);return o(e)?dt(n,e,void 0,i):n}}function getResolver(t,e,s){let i=t.get(e);if(!i){i=new Map;t.set(e,i)}const n=s.join();let o=i.get(n);if(!o){const t=ut(e,s);o={resolver:t,subPrefixes:s.filter((t=>!t.toLowerCase().includes("hover")))};i.set(n,o)}return o}const hasFunction=t=>o(t)&&Object.getOwnPropertyNames(t).reduce(((e,s)=>e||ht(t[s])),false);function needContext(t,e){const{isScriptable:s,isIndexable:i}=gt(t);for(const n of e){const e=s(n);const o=i(n);const r=(o||e)&&t[n];if(e&&(ht(r)||hasFunction(r))||o&&a(r))return true}return false}var _e="3.9.1";const ye=["top","bottom","left","right","chartArea"];function positionIsHorizontal(t,e){return"top"===t||"bottom"===t||-1===ye.indexOf(t)&&"x"===e}function compare2Level(t,e){return function(s,i){return s[t]===i[t]?s[e]-i[e]:s[t]-i[t]}}function onAnimationsComplete(t){const e=t.chart;const s=e.options.animation;e.notifyPlugins("afterRender");z(s&&s.onComplete,[t],e)}function onAnimationProgress(t){const e=t.chart;const s=e.options.animation;z(s&&s.onProgress,[t],e)}function getCanvas(t){rt()&&"string"===typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]);t&&t.canvas&&(t=t.canvas);return t}const ve={};const getChart=t=>{const e=getCanvas(t);return Object.values(ve).filter((t=>t.canvas===e)).pop()};function moveNumericKeys(t,e,s){const i=Object.keys(t);for(const n of i){const i=+n;if(i>=e){const o=t[n];delete t[n];(s>0||i>e)&&(t[i+s]=o)}}}function determineLastEvent(t,e,s,i){return s&&"mouseout"!==t.type?i?e:t:null}class Chart{constructor(t,e){const s=this.config=new Config(e);const i=getCanvas(t);const n=getChart(i);if(n)throw new Error("Canvas is already in use. Chart with ID '"+n.id+"' must be destroyed before the canvas with ID '"+n.canvas.id+"' can be reused.");const o=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||_detectPlatform(i));this.platform.updateConfig(s);const a=this.platform.acquireContext(i,o.aspectRatio);const r=a&&a.canvas;const l=r&&r.height;const c=r&&r.width;this.id=ft();this.ctx=a;this.canvas=r;this.width=c;this.height=l;this._options=o;this._aspectRatio=this.aspectRatio;this._layers=[];this._metasets=[];this._stacks=void 0;this.boxes=[];this.currentDevicePixelRatio=void 0;this.chartArea=void 0;this._active=[];this._lastEvent=void 0;this._listeners={};this._responsiveListeners=void 0;this._sortedMetasets=[];this.scales={};this._plugins=new PluginService;this.$proxies={};this._hiddenIndices={};this.attached=false;this._animationsDisabled=void 0;this.$context=void 0;this._doResize=pt((t=>this.update(t)),o.resizeDelay||0);this._dataChanges=[];ve[this.id]=this;if(a&&r){Zt.listen(this,"complete",onAnimationsComplete);Zt.listen(this,"progress",onAnimationProgress);this._initialize();this.attached&&this.update()}else console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:s,height:i,_aspectRatio:n}=this;return x(t)?e&&n?n:i?s/i:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}_initialize(){this.notifyPlugins("beforeInit");this.options.responsive?this.resize():mt(this,this.options.devicePixelRatio);this.bindEvents();this.notifyPlugins("afterInit");return this}clear(){xt(this.canvas,this.ctx);return this}stop(){Zt.stop(this);return this}resize(t,e){Zt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const s=this.options;const i=this.canvas;const n=s.maintainAspectRatio&&this.aspectRatio;const o=this.platform.getMaximumSize(i,t,e,n);const a=s.devicePixelRatio||this.platform.getDevicePixelRatio();const r=this.width?"resize":"attach";this.width=o.width;this.height=o.height;this._aspectRatio=this.aspectRatio;if(mt(this,a,true)){this.notifyPlugins("resize",{size:o});z(s.onResize,[this,o],this);this.attached&&this._doResize(r)&&this.render()}}ensureScalesHaveIDs(){const t=this.options;const e=t.scales||{};O(e,((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options;const e=t.scales;const s=this.scales;const i=Object.keys(s).reduce(((t,e)=>{t[e]=false;return t}),{});let n=[];e&&(n=n.concat(Object.keys(e).map((t=>{const s=e[t];const i=determineAxis(t,s);const n="r"===i;const o="x"===i;return{options:s,dposition:n?"chartArea":o?"bottom":"left",dtype:n?"radialLinear":o?"category":"linear"}}))));O(n,(e=>{const n=e.options;const o=n.id;const a=determineAxis(o,n);const r=h(n.type,e.dtype);void 0!==n.position&&positionIsHorizontal(n.position,a)===positionIsHorizontal(e.dposition)||(n.position=e.dposition);i[o]=true;let l=null;if(o in s&&s[o].type===r)l=s[o];else{const t=ae.getScale(r);l=new t({id:o,type:r,ctx:this.ctx,chart:this});s[l.id]=l}l.init(n,t)}));O(i,((t,e)=>{t||delete s[e]}));O(s,(t=>{de.configure(this,t,t.options);de.addBox(this,t)}))}_updateMetasets(){const t=this._metasets;const e=this.data.datasets.length;const s=t.length;t.sort(((t,e)=>t.index-e.index));if(s>e){for(let t=e;t<s;++t)this._destroyDatasetMeta(t);t.splice(e,s-e)}this._sortedMetasets=t.slice(0).sort(compare2Level("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks;t.forEach(((t,s)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(s)}))}buildOrUpdateControllers(){const t=[];const e=this.data.datasets;let s,i;this._removeUnreferencedMetasets();for(s=0,i=e.length;s<i;s++){const i=e[s];let o=this.getDatasetMeta(s);const a=i.type||this.config.type;if(o.type&&o.type!==a){this._destroyDatasetMeta(s);o=this.getDatasetMeta(s)}o.type=a;o.indexAxis=i.indexAxis||getIndexAxis(a,this.options);o.order=i.order||0;o.index=s;o.label=""+i.label;o.visible=this.isDatasetVisible(s);if(o.controller){o.controller.updateIndex(s);o.controller.linkScales()}else{const e=ae.getController(a);const{datasetElementType:i,dataElementType:r}=n.datasets[a];Object.assign(e.prototype,{dataElementType:ae.getElement(r),datasetElementType:i&&ae.getElement(i)});o.controller=new e(this,s);t.push(o.controller)}}this._updateMetasets();return t}_resetElements(){O(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements();this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const s=this._options=e.createResolver(e.chartOptionScopes(),this.getContext());const i=this._animationsDisabled=!s.animation;this._updateScales();this._checkEventBindings();this._updateHiddenIndices();this._plugins.invalidate();if(false===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:true}))return;const n=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let t=0,e=this.data.datasets.length;t<e;t++){const{controller:e}=this.getDatasetMeta(t);const s=!i&&-1===n.indexOf(e);e.buildOrUpdateElements(s);o=Math.max(+e.getMaxOverflow(),o)}o=this._minPadding=s.layout.autoPadding?o:0;this._updateLayout(o);i||O(n,(t=>{t.reset()}));this._updateDatasets(t);this.notifyPlugins("afterUpdate",{mode:t});this._layers.sort(compare2Level("z","_idx"));const{_active:a,_lastEvent:r}=this;r?this._eventHandler(r,true):a.length&&this._updateHoverStyles(a,a,true);this.render()}_updateScales(){O(this.scales,(t=>{de.removeBox(this,t)}));this.ensureScalesHaveIDs();this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options;const e=new Set(Object.keys(this._listeners));const s=new Set(t.events);if(!bt(e,s)||!!this._responsiveListeners!==t.responsive){this.unbindEvents();this.bindEvents()}}_updateHiddenIndices(){const{_hiddenIndices:t}=this;const e=this._getUniformDataChanges()||[];for(const{method:s,start:i,count:n}of e){const e="_removeElements"===s?-n:n;moveNumericKeys(t,i,e)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length;const makeSet=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+","+t.splice(1).join(","))));const s=makeSet(0);for(let t=1;t<e;t++)if(!bt(s,makeSet(t)))return;return Array.from(s).map((t=>t.split(","))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(false===this.notifyPlugins("beforeLayout",{cancelable:true}))return;de.update(this,this.width,this.height,t);const e=this.chartArea;const s=e.width<=0||e.height<=0;this._layers=[];O(this.boxes,(t=>{if(!s||"chartArea"!==t.position){t.configure&&t.configure();this._layers.push(...t._layers())}}),this);this._layers.forEach(((t,e)=>{t._idx=e}));this.notifyPlugins("afterLayout")}_updateDatasets(t){if(false!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:true})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,s=this.data.datasets.length;e<s;++e)this._updateDataset(e,ht(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const s=this.getDatasetMeta(t);const i={meta:s,index:t,mode:e,cancelable:true};if(false!==this.notifyPlugins("beforeDatasetUpdate",i)){s.controller._update(e);i.cancelable=false;this.notifyPlugins("afterDatasetUpdate",i)}}render(){if(false!==this.notifyPlugins("beforeRender",{cancelable:true}))if(Zt.has(this))this.attached&&!Zt.running(this)&&Zt.start(this);else{this.draw();onAnimationsComplete({chart:this})}}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resize(t,e);this._resizeBeforeDraw=null}this.clear();if(this.width<=0||this.height<=0)return;if(false===this.notifyPlugins("beforeDraw",{cancelable:true}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);this._drawDatasets();for(;t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets;const s=[];let i,n;for(i=0,n=e.length;i<n;++i){const n=e[i];t&&!n.visible||s.push(n)}return s}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(true)}_drawDatasets(){if(false===this.notifyPlugins("beforeDatasetsDraw",{cancelable:true}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx;const s=t._clip;const i=!s.disabled;const n=this.chartArea;const o={meta:t,index:t.index,cancelable:true};if(false!==this.notifyPlugins("beforeDatasetDraw",o)){i&&U(e,{left:false===s.left?0:n.left-s.left,right:false===s.right?this.width:n.right+s.right,top:false===s.top?0:n.top-s.top,bottom:false===s.bottom?this.height:n.bottom+s.bottom});t.controller.draw();i&&X(e);o.cancelable=false;this.notifyPlugins("afterDatasetDraw",o)}}isPointInArea(t){return Q(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,s,i){const n=ce.modes[e];return"function"===typeof n?n(this,t,s,i):[]}getDatasetMeta(t){const e=this.data.datasets[t];const s=this._metasets;let i=s.filter((t=>t&&t._dataset===e)).pop();if(!i){i={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:false};s.push(i)}return i}getContext(){return this.$context||(this.$context=c(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return false;const s=this.getDatasetMeta(t);return"boolean"===typeof s.hidden?!s.hidden:!e.hidden}setDatasetVisibility(t,e){const s=this.getDatasetMeta(t);s.hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,s){const i=s?"show":"hide";const n=this.getDatasetMeta(t);const o=n.controller._resolveAnimations(void 0,i);if(p(e)){n.data[e].hidden=!s;this.update()}else{this.setDatasetVisibility(t,s);o.update(n,{visible:s});this.update((e=>e.datasetIndex===t?i:void 0))}}hide(t,e){this._updateVisibility(t,e,false)}show(t,e){this._updateVisibility(t,e,true)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy();delete this._metasets[t]}_stop(){let t,e;this.stop();Zt.remove(this);for(t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop();this.config.clearCache();if(t){this.unbindEvents();xt(t,e);this.platform.releaseContext(e);this.canvas=null;this.ctx=null}this.notifyPlugins("destroy");delete ve[this.id];this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents();this.options.responsive?this.bindResponsiveEvents():this.attached=true}bindUserEvents(){const t=this._listeners;const e=this.platform;const _add=(s,i)=>{e.addEventListener(this,s,i);t[s]=i};const listener=(t,e,s)=>{t.offsetX=e;t.offsetY=s;this._eventHandler(t)};O(this.options.events,(t=>_add(t,listener)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners;const e=this.platform;const _add=(s,i)=>{e.addEventListener(this,s,i);t[s]=i};const _remove=(s,i)=>{if(t[s]){e.removeEventListener(this,s,i);delete t[s]}};const listener=(t,e)=>{this.canvas&&this.resize(t,e)};let s;const attached=()=>{_remove("attach",attached);this.attached=true;this.resize();_add("resize",listener);_add("detach",s)};s=()=>{this.attached=false;_remove("resize",listener);this._stop();this._resize(0,0);_add("attach",attached)};e.isAttached(this.canvas)?attached():s()}unbindEvents(){O(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)}));this._listeners={};O(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)}));this._responsiveListeners=void 0}updateHoverStyle(t,e,s){const i=s?"set":"remove";let n,o,a,r;if("dataset"===e){n=this.getDatasetMeta(t[0].datasetIndex);n.controller["_"+i+"DatasetHoverStyle"]()}for(a=0,r=t.length;a<r;++a){o=t[a];const e=o&&this.getDatasetMeta(o.datasetIndex).controller;e&&e[i+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[];const s=t.map((({datasetIndex:t,index:e})=>{const s=this.getDatasetMeta(t);if(!s)throw new Error("No dataset found at index "+t);return{datasetIndex:t,element:s.data[e],index:e}}));const i=!_t(s,e);if(i){this._active=s;this._lastEvent=null;this._updateHoverStyles(s,e)}}notifyPlugins(t,e,s){return this._plugins.notify(this,t,e,s)}_updateHoverStyles(t,e,s){const i=this.options.hover;const diff=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index))));const n=diff(e,t);const o=s?t:diff(t,e);n.length&&this.updateHoverStyle(n,i.mode,false);o.length&&i.mode&&this.updateHoverStyle(o,i.mode,true)}_eventHandler(t,e){const s={event:t,replay:e,cancelable:true,inChartArea:this.isPointInArea(t)};const eventFilter=e=>(e.options.events||this.options.events).includes(t.native.type);if(false===this.notifyPlugins("beforeEvent",s,eventFilter))return;const i=this._handleEvent(t,e,s.inChartArea);s.cancelable=false;this.notifyPlugins("afterEvent",s,eventFilter);(i||s.changed)&&this.render();return this}_handleEvent(t,e,s){const{_active:i=[],options:n}=this;const o=e;const a=this._getActiveElements(t,i,s,o);const r=yt(t);const l=determineLastEvent(t,this._lastEvent,s,r);if(s){this._lastEvent=null;z(n.onHover,[t,a,this],this);r&&z(n.onClick,[t,a,this],this)}const c=!_t(a,i);if(c||e){this._active=a;this._updateHoverStyles(a,i,e)}this._lastEvent=l;return c}_getActiveElements(t,e,s,i){if("mouseout"===t.type)return[];if(!s)return e;const n=this.options.hover;return this.getElementsAtEventForMode(t,n.mode,n,i)}}const invalidatePlugins=()=>O(Chart.instances,(t=>t._plugins.invalidate()));const ke=true;Object.defineProperties(Chart,{defaults:{enumerable:ke,value:n},instances:{enumerable:ke,value:ve},overrides:{enumerable:ke,value:K},registry:{enumerable:ke,value:ae},version:{enumerable:ke,value:_e},getChart:{enumerable:ke,value:getChart},register:{enumerable:ke,value:(...t)=>{ae.add(...t);invalidatePlugins()}},unregister:{enumerable:ke,value:(...t)=>{ae.remove(...t);invalidatePlugins()}}});function clipArc(t,e,s){const{startAngle:i,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=e;let c=n/r;t.beginPath();t.arc(o,a,r,i-c,s+c);if(l>n){c=n/l;t.arc(o,a,l,s+c,i-c,true)}else t.arc(o,a,n,s+y,i-y);t.closePath();t.clip()}function toRadiusCorners(t){return vt(t,["outerStart","outerEnd","innerStart","innerEnd"])}function parseBorderRadius$1(t,e,s,i){const n=toRadiusCorners(t.options.borderRadius);const o=(s-e)/2;const a=Math.min(o,i*e/2);const computeOuterLimit=t=>{const e=(s-Math.min(o,t))*i/2;return N(t,0,Math.min(o,e))};return{outerStart:computeOuterLimit(n.outerStart),outerEnd:computeOuterLimit(n.outerEnd),innerStart:N(n.innerStart,0,a),innerEnd:N(n.innerEnd,0,a)}}function rThetaToXY(t,e,s,i){return{x:s+t*Math.cos(e),y:i+t*Math.sin(e)}}function pathArc(t,e,s,i,n,o){const{x:a,y:r,startAngle:l,pixelMargin:c,innerRadius:h}=e;const d=Math.max(e.outerRadius+i+s-c,0);const u=h>0?h+i+s+c:0;let g=0;const f=n-l;if(i){const t=h>0?h-i:0;const e=d>0?d-i:0;const s=(t+e)/2;const n=0!==s?f*s/(s+i):f;g=(f-n)/2}const p=Math.max(.001,f*d-s/v)/d;const m=(f-p)/2;const x=l+m+g;const b=n-m-g;const{outerStart:_,outerEnd:k,innerStart:M,innerEnd:S}=parseBorderRadius$1(e,u,d,b-x);const w=d-_;const C=d-k;const D=x+_/w;const P=b-k/C;const A=u+M;const L=u+S;const T=x+M/A;const O=b-S/L;t.beginPath();if(o){t.arc(a,r,d,D,P);if(k>0){const e=rThetaToXY(C,P,a,r);t.arc(e.x,e.y,k,P,b+y)}const e=rThetaToXY(L,b,a,r);t.lineTo(e.x,e.y);if(S>0){const e=rThetaToXY(L,O,a,r);t.arc(e.x,e.y,S,b+y,O+Math.PI)}t.arc(a,r,u,b-S/u,x+M/u,true);if(M>0){const e=rThetaToXY(A,T,a,r);t.arc(e.x,e.y,M,T+Math.PI,x-y)}const s=rThetaToXY(w,x,a,r);t.lineTo(s.x,s.y);if(_>0){const e=rThetaToXY(w,D,a,r);t.arc(e.x,e.y,_,x-y,D)}}else{t.moveTo(a,r);const e=Math.cos(D)*d+a;const s=Math.sin(D)*d+r;t.lineTo(e,s);const i=Math.cos(P)*d+a;const n=Math.sin(P)*d+r;t.lineTo(i,n)}t.closePath()}function drawArc(t,e,s,i,n){const{fullCircles:o,startAngle:a,circumference:r}=e;let l=e.endAngle;if(o){pathArc(t,e,s,i,a+b,n);for(let e=0;e<o;++e)t.fill();if(!isNaN(r)){l=a+r%b;r%b===0&&(l+=b)}}pathArc(t,e,s,i,l,n);t.fill();return l}function drawFullCircleBorders(t,e,s){const{x:i,y:n,startAngle:o,pixelMargin:a,fullCircles:r}=e;const l=Math.max(e.outerRadius-a,0);const c=e.innerRadius+a;let h;s&&clipArc(t,e,o+b);t.beginPath();t.arc(i,n,c,o+b,o,true);for(h=0;h<r;++h)t.stroke();t.beginPath();t.arc(i,n,l,o,o+b);for(h=0;h<r;++h)t.stroke()}function drawBorder(t,e,s,i,n,o){const{options:a}=e;const{borderWidth:r,borderJoinStyle:l}=a;const c="inner"===a.borderAlign;if(r){if(c){t.lineWidth=2*r;t.lineJoin=l||"round"}else{t.lineWidth=r;t.lineJoin=l||"bevel"}e.fullCircles&&drawFullCircleBorders(t,e,c);c&&clipArc(t,e,n);pathArc(t,e,s,i,n,o);t.stroke()}}class ArcElement extends Element{constructor(t){super();this.options=void 0;this.circumference=void 0;this.startAngle=void 0;this.endAngle=void 0;this.innerRadius=void 0;this.outerRadius=void 0;this.pixelMargin=0;this.fullCircles=0;t&&Object.assign(this,t)}inRange(t,e,s){const i=this.getProps(["x","y"],s);const{angle:n,distance:o}=tt(i,{x:t,y:e});const{startAngle:a,endAngle:r,innerRadius:l,outerRadius:c,circumference:d}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],s);const u=this.options.spacing/2;const g=h(d,r-a);const f=g>=b||_(n,a,r);const p=kt(o,l+u,c+u);return f&&p}getCenterPoint(t){const{x:e,y:s,startAngle:i,endAngle:n,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius","circumference"],t);const{offset:r,spacing:l}=this.options;const c=(i+n)/2;const h=(o+a+l+r)/2;return{x:e+Math.cos(c)*h,y:s+Math.sin(c)*h}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:s}=this;const i=(e.offset||0)/2;const n=(e.spacing||0)/2;const o=e.circular;this.pixelMargin="inner"===e.borderAlign?.33:0;this.fullCircles=s>b?Math.floor(s/b):0;if(0===s||this.innerRadius<0||this.outerRadius<0)return;t.save();let a=0;if(i){a=i/2;const e=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(e)*a,Math.sin(e)*a);this.circumference>=v&&(a=i)}t.fillStyle=e.backgroundColor;t.strokeStyle=e.borderColor;const r=drawArc(t,this,a,n,o);drawBorder(t,this,a,n,r,o);t.restore()}}ArcElement.id="arc";ArcElement.defaults={borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:true};ArcElement.defaultRoutes={backgroundColor:"backgroundColor"};function setStyle(t,e,s=e){t.lineCap=h(s.borderCapStyle,e.borderCapStyle);t.setLineDash(h(s.borderDash,e.borderDash));t.lineDashOffset=h(s.borderDashOffset,e.borderDashOffset);t.lineJoin=h(s.borderJoinStyle,e.borderJoinStyle);t.lineWidth=h(s.borderWidth,e.borderWidth);t.strokeStyle=h(s.borderColor,e.borderColor)}function lineTo(t,e,s){t.lineTo(s.x,s.y)}function getLineMethod(t){return t.stepped?Mt:t.tension||"monotone"===t.cubicInterpolationMode?St:lineTo}function pathVars(t,e,s={}){const i=t.length;const{start:n=0,end:o=i-1}=s;const{start:a,end:r}=e;const l=Math.max(n,a);const c=Math.min(o,r);const h=n<a&&o<a||n>r&&o>r;return{count:i,start:l,loop:e.loop,ilen:c<l&&!h?i+c-l:c-l}}function pathSegment(t,e,s,i){const{points:n,options:o}=e;const{count:a,start:r,loop:l,ilen:c}=pathVars(n,s,i);const h=getLineMethod(o);let{move:d=true,reverse:u}=i||{};let g,f,p;for(g=0;g<=c;++g){f=n[(r+(u?c-g:g))%a];if(!f.skip){if(d){t.moveTo(f.x,f.y);d=false}else h(t,p,f,u,o.stepped);p=f}}if(l){f=n[(r+(u?c:0))%a];h(t,p,f,u,o.stepped)}return!!l}function fastPathSegment(t,e,s,i){const n=e.points;const{count:o,start:a,ilen:r}=pathVars(n,s,i);const{move:l=true,reverse:c}=i||{};let h=0;let d=0;let u,g,f,p,m,x;const pointIndex=t=>(a+(c?r-t:t))%o;const drawX=()=>{if(p!==m){t.lineTo(h,m);t.lineTo(h,p);t.lineTo(h,x)}};if(l){g=n[pointIndex(0)];t.moveTo(g.x,g.y)}for(u=0;u<=r;++u){g=n[pointIndex(u)];if(g.skip)continue;const e=g.x;const s=g.y;const i=0|e;if(i===f){s<p?p=s:s>m&&(m=s);h=(d*h+e)/++d}else{drawX();t.lineTo(e,s);f=i;d=0;p=m=s}x=s}drawX()}function _getSegmentMethod(t){const e=t.options;const s=e.borderDash&&e.borderDash.length;const i=!t._decimated&&!t._loop&&!e.tension&&"monotone"!==e.cubicInterpolationMode&&!e.stepped&&!s;return i?fastPathSegment:pathSegment}function _getInterpolationMethod(t){return t.stepped?wt:t.tension||"monotone"===t.cubicInterpolationMode?Ct:Dt}function strokePathWithCache(t,e,s,i){let n=e._path;if(!n){n=e._path=new Path2D;e.path(n,s,i)&&n.closePath()}setStyle(t,e.options);t.stroke(n)}function strokePathDirect(t,e,s,i){const{segments:n,options:o}=e;const a=_getSegmentMethod(e);for(const r of n){setStyle(t,o,r.style);t.beginPath();a(t,e,r,{start:s,end:s+i-1})&&t.closePath();t.stroke()}}const Me="function"===typeof Path2D;function draw(t,e,s,i){Me&&!e.options.segment?strokePathWithCache(t,e,s,i):strokePathDirect(t,e,s,i)}class LineElement extends Element{constructor(t){super();this.animated=true;this.options=void 0;this._chart=void 0;this._loop=void 0;this._fullLoop=void 0;this._path=void 0;this._points=void 0;this._segments=void 0;this._decimated=false;this._pointsUpdated=false;this._datasetIndex=void 0;t&&Object.assign(this,t)}updateControlPoints(t,e){const s=this.options;if((s.tension||"monotone"===s.cubicInterpolationMode)&&!s.stepped&&!this._pointsUpdated){const i=s.spanGaps?this._loop:this._fullLoop;Pt(this._points,s,t,i,e);this._pointsUpdated=true}}set points(t){this._points=t;delete this._segments;delete this._path;this._pointsUpdated=false}get points(){return this._points}get segments(){return this._segments||(this._segments=At(this,this.options.segment))}first(){const t=this.segments;const e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments;const e=this.points;const s=t.length;return s&&e[t[s-1].end]}interpolate(t,e){const s=this.options;const i=t[e];const n=this.points;const o=Lt(this,{property:e,start:i,end:i});if(!o.length)return;const a=[];const r=_getInterpolationMethod(s);let l,c;for(l=0,c=o.length;l<c;++l){const{start:c,end:h}=o[l];const d=n[c];const u=n[h];if(d===u){a.push(d);continue}const g=Math.abs((i-d[e])/(u[e]-d[e]));const f=r(d,u,g,s.stepped);f[e]=t[e];a.push(f)}return 1===a.length?a[0]:a}pathSegment(t,e,s){const i=_getSegmentMethod(this);return i(t,this,e,s)}path(t,e,s){const i=this.segments;const n=_getSegmentMethod(this);let o=this._loop;e=e||0;s=s||this.points.length-e;for(const a of i)o&=n(t,this,a,{start:e,end:e+s-1});return!!o}draw(t,e,s,i){const n=this.options||{};const o=this.points||[];if(o.length&&n.borderWidth){t.save();draw(t,this,s,i);t.restore()}if(this.animated){this._pointsUpdated=false;this._path=void 0}}}LineElement.id="line";LineElement.defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:true,cubicInterpolationMode:"default",fill:false,spanGaps:false,stepped:false,tension:0};LineElement.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};LineElement.descriptors={_scriptable:true,_indexable:t=>"borderDash"!==t&&"fill"!==t};function inRange$1(t,e,s,i){const n=t.options;const{[s]:o}=t.getProps([s],i);return Math.abs(e-o)<n.radius+n.hitRadius}class PointElement extends Element{constructor(t){super();this.options=void 0;this.parsed=void 0;this.skip=void 0;this.stop=void 0;t&&Object.assign(this,t)}inRange(t,e,s){const i=this.options;const{x:n,y:o}=this.getProps(["x","y"],s);return Math.pow(t-n,2)+Math.pow(e-o,2)<Math.pow(i.hitRadius+i.radius,2)}inXRange(t,e){return inRange$1(this,t,"x",e)}inYRange(t,e){return inRange$1(this,t,"y",e)}getCenterPoint(t){const{x:e,y:s}=this.getProps(["x","y"],t);return{x:e,y:s}}size(t){t=t||this.options||{};let e=t.radius||0;e=Math.max(e,e&&t.hoverRadius||0);const s=e&&t.borderWidth||0;return 2*(e+s)}draw(t,e){const s=this.options;if(!(this.skip||s.radius<.1)&&Q(this,e,this.size(s)/2)){t.strokeStyle=s.borderColor;t.lineWidth=s.borderWidth;t.fillStyle=s.backgroundColor;Tt(t,s,this.x,this.y)}}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}PointElement.id="point";PointElement.defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};PointElement.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};function getBarBounds(t,e){const{x:s,y:i,base:n,width:o,height:a}=t.getProps(["x","y","base","width","height"],e);let r,l,c,h,d;if(t.horizontal){d=a/2;r=Math.min(s,n);l=Math.max(s,n);c=i-d;h=i+d}else{d=o/2;r=s-d;l=s+d;c=Math.min(i,n);h=Math.max(i,n)}return{left:r,top:c,right:l,bottom:h}}function skipOrLimit(t,e,s,i){return t?0:N(e,s,i)}function parseBorderWidth(t,e,s){const i=t.options.borderWidth;const n=t.borderSkipped;const o=Ot(i);return{t:skipOrLimit(n.top,o.top,0,s),r:skipOrLimit(n.right,o.right,0,e),b:skipOrLimit(n.bottom,o.bottom,0,s),l:skipOrLimit(n.left,o.left,0,e)}}function parseBorderRadius(t,e,s){const{enableBorderRadius:i}=t.getProps(["enableBorderRadius"]);const n=t.options.borderRadius;const a=Et(n);const r=Math.min(e,s);const l=t.borderSkipped;const c=i||o(n);return{topLeft:skipOrLimit(!c||l.top||l.left,a.topLeft,0,r),topRight:skipOrLimit(!c||l.top||l.right,a.topRight,0,r),bottomLeft:skipOrLimit(!c||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:skipOrLimit(!c||l.bottom||l.right,a.bottomRight,0,r)}}function boundingRects(t){const e=getBarBounds(t);const s=e.right-e.left;const i=e.bottom-e.top;const n=parseBorderWidth(t,s/2,i/2);const o=parseBorderRadius(t,s/2,i/2);return{outer:{x:e.left,y:e.top,w:s,h:i,radius:o},inner:{x:e.left+n.l,y:e.top+n.t,w:s-n.l-n.r,h:i-n.t-n.b,radius:{topLeft:Math.max(0,o.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,o.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,o.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,o.bottomRight-Math.max(n.b,n.r))}}}}function inRange(t,e,s,i){const n=null===e;const o=null===s;const a=n&&o;const r=t&&!a&&getBarBounds(t,i);return r&&(n||kt(e,r.left,r.right))&&(o||kt(s,r.top,r.bottom))}function hasRadius(t){return t.topLeft||t.topRight||t.bottomLeft||t.bottomRight}function addNormalRectPath(t,e){t.rect(e.x,e.y,e.w,e.h)}function inflateRect(t,e,s={}){const i=t.x!==s.x?-e:0;const n=t.y!==s.y?-e:0;const o=(t.x+t.w!==s.x+s.w?e:0)-i;const a=(t.y+t.h!==s.y+s.h?e:0)-n;return{x:t.x+i,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}class BarElement extends Element{constructor(t){super();this.options=void 0;this.horizontal=void 0;this.base=void 0;this.width=void 0;this.height=void 0;this.inflateAmount=void 0;t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:s,backgroundColor:i}}=this;const{inner:n,outer:o}=boundingRects(this);const a=hasRadius(o.radius)?Rt:addNormalRectPath;t.save();if(o.w!==n.w||o.h!==n.h){t.beginPath();a(t,inflateRect(o,e,n));t.clip();a(t,inflateRect(n,-e,o));t.fillStyle=s;t.fill("evenodd")}t.beginPath();a(t,inflateRect(n,e));t.fillStyle=i;t.fill();t.restore()}inRange(t,e,s){return inRange(this,t,e,s)}inXRange(t,e){return inRange(this,t,null,e)}inYRange(t,e){return inRange(this,null,t,e)}getCenterPoint(t){const{x:e,y:s,base:i,horizontal:n}=this.getProps(["x","y","base","horizontal"],t);return{x:n?(e+i)/2:e,y:n?s:(s+i)/2}}getRange(t){return"x"===t?this.width/2:this.height/2}}BarElement.id="bar";BarElement.defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};BarElement.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};var Se=Object.freeze({__proto__:null,ArcElement:ArcElement,LineElement:LineElement,PointElement:PointElement,BarElement:BarElement});function lttbDecimation(t,e,s,i,n){const o=n.samples||i;if(o>=s)return t.slice(e,e+s);const a=[];const r=(s-2)/(o-2);let l=0;const c=e+s-1;let h=e;let d,u,g,f,p;a[l++]=t[h];for(d=0;d<o-2;d++){let i=0;let n=0;let o;const c=Math.floor((d+1)*r)+1+e;const m=Math.min(Math.floor((d+2)*r)+1,s)+e;const x=m-c;for(o=c;o<m;o++){i+=t[o].x;n+=t[o].y}i/=x;n/=x;const b=Math.floor(d*r)+1+e;const _=Math.min(Math.floor((d+1)*r)+1,s)+e;const{x:y,y:v}=t[h];g=f=-1;for(o=b;o<_;o++){f=.5*Math.abs((y-i)*(t[o].y-v)-(y-t[o].x)*(n-v));if(f>g){g=f;u=t[o];p=o}}a[l++]=u;h=p}a[l++]=t[c];return a}function minMaxDecimation(t,e,s,i){let n=0;let o=0;let a,r,l,c,h,d,u,g,f,p;const m=[];const b=e+s-1;const _=t[e].x;const y=t[b].x;const v=y-_;for(a=e;a<e+s;++a){r=t[a];l=(r.x-_)/v*i;c=r.y;const e=0|l;if(e===h){if(c<f){f=c;d=a}else if(c>p){p=c;u=a}n=(o*n+r.x)/++o}else{const s=a-1;if(!x(d)&&!x(u)){const e=Math.min(d,u);const i=Math.max(d,u);e!==g&&e!==s&&m.push({...t[e],x:n});i!==g&&i!==s&&m.push({...t[i],x:n})}a>0&&s!==g&&m.push(t[s]);m.push(r);h=e;o=0;f=p=c;d=u=g=a}}return m}function cleanDecimatedDataset(t){if(t._decimated){const e=t._data;delete t._decimated;delete t._data;Object.defineProperty(t,"data",{value:e})}}function cleanDecimatedData(t){t.data.datasets.forEach((t=>{cleanDecimatedDataset(t)}))}function getStartAndCountOfVisiblePointsSimplified(t,e){const s=e.length;let i=0;let n;const{iScale:o}=t;const{min:a,max:r,minDefined:l,maxDefined:c}=o.getUserBounds();l&&(i=N(Z(e,o.axis,a).lo,0,s-1));n=c?N(Z(e,o.axis,r).hi+1,i,s)-i:s-i;return{start:i,count:n}}var we={id:"decimation",defaults:{algorithm:"min-max",enabled:false},beforeElementsUpdate:(t,e,i)=>{if(!i.enabled){cleanDecimatedData(t);return}const n=t.width;t.data.datasets.forEach(((e,o)=>{const{_data:a,indexAxis:r}=e;const l=t.getDatasetMeta(o);const c=a||e.data;if("y"===s([r,t.options.indexAxis]))return;if(!l.controller.supportsDecimation)return;const h=t.scales[l.xAxisID];if("linear"!==h.type&&"time"!==h.type)return;if(t.options.parsing)return;let{start:d,count:u}=getStartAndCountOfVisiblePointsSimplified(l,c);const g=i.threshold||4*n;if(u<=g){cleanDecimatedDataset(e);return}if(x(a)){e._data=c;delete e.data;Object.defineProperty(e,"data",{configurable:true,enumerable:true,get:function(){return this._decimated},set:function(t){this._data=t}})}let f;switch(i.algorithm){case"lttb":f=lttbDecimation(c,d,u,n,i);break;case"min-max":f=minMaxDecimation(c,d,u,n);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}e._decimated=f}))},destroy(t){cleanDecimatedData(t)}};function _segments(t,e,s){const i=t.segments;const n=t.points;const o=e.points;const a=[];for(const t of i){let{start:i,end:r}=t;r=_findSegmentEnd(i,r,n);const l=_getBounds(s,n[i],n[r],t.loop);if(!e.segments){a.push({source:t,target:l,start:n[i],end:n[r]});continue}const c=Lt(e,l);for(const e of c){const i=_getBounds(s,o[e.start],o[e.end],e.loop);const r=It(t,n,i);for(const t of r)a.push({source:t,target:e,start:{[s]:_getEdge(l,i,"start",Math.max)},end:{[s]:_getEdge(l,i,"end",Math.min)}})}}return a}function _getBounds(t,e,s,i){if(i)return;let n=e[t];let o=s[t];if("angle"===t){n=Bt(n);o=Bt(o)}return{property:t,start:n,end:o}}function _pointsFromSegments(t,e){const{x:s=null,y:i=null}=t||{};const n=e.points;const o=[];e.segments.forEach((({start:t,end:e})=>{e=_findSegmentEnd(t,e,n);const a=n[t];const r=n[e];if(null!==i){o.push({x:a.x,y:i});o.push({x:r.x,y:i})}else if(null!==s){o.push({x:s,y:a.y});o.push({x:s,y:r.y})}}));return o}function _findSegmentEnd(t,e,s){for(;e>t;e--){const t=s[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function _getEdge(t,e,s,i){return t&&e?i(t[s],e[s]):t?t[s]:e?e[s]:0}function _createBoundaryLine(t,e){let s=[];let i=false;if(a(t)){i=true;s=t}else s=_pointsFromSegments(t,e);return s.length?new LineElement({points:s,options:{tension:0},_loop:i,_fullLoop:i}):null}function _shouldApplyFill(t){return t&&false!==t.fill}function _resolveTarget(t,e,s){const i=t[e];let n=i.fill;const o=[e];let a;if(!s)return n;while(false!==n&&-1===o.indexOf(n)){if(!r(n))return n;a=t[n];if(!a)return false;if(a.visible)return n;o.push(n);n=a.fill}return false}function _decodeFill(t,e,s){const i=parseFillOption(t);if(o(i))return!isNaN(i.value)&&i;let n=parseFloat(i);return r(n)&&Math.floor(n)===n?decodeTargetIndex(i[0],e,n,s):["origin","start","end","stack","shape"].indexOf(i)>=0&&i}function decodeTargetIndex(t,e,s,i){"-"!==t&&"+"!==t||(s=e+s);return!(s===e||s<0||s>=i)&&s}function _getTargetPixel(t,e){let s=null;"start"===t?s=e.bottom:"end"===t?s=e.top:o(t)?s=e.getPixelForValue(t.value):e.getBasePixel&&(s=e.getBasePixel());return s}function _getTargetValue(t,e,s){let i;i="start"===t?s:"end"===t?e.options.reverse?e.min:e.max:o(t)?t.value:e.getBaseValue();return i}function parseFillOption(t){const e=t.options;const s=e.fill;let i=h(s&&s.target,s);void 0===i&&(i=!!e.backgroundColor);return false!==i&&null!==i&&(true===i?"origin":i)}function _buildStackLine(t){const{scale:e,index:s,line:i}=t;const n=[];const o=i.segments;const a=i.points;const r=getLinesBelow(e,s);r.push(_createBoundaryLine({x:null,y:e.bottom},i));for(let t=0;t<o.length;t++){const e=o[t];for(let t=e.start;t<=e.end;t++)addPointsBelow(n,a[t],r)}return new LineElement({points:n,options:{}})}function getLinesBelow(t,e){const s=[];const i=t.getMatchingVisibleMetas("line");for(let t=0;t<i.length;t++){const n=i[t];if(n.index===e)break;n.hidden||s.unshift(n.dataset)}return s}function addPointsBelow(t,e,s){const i=[];for(let n=0;n<s.length;n++){const o=s[n];const{first:a,last:r,point:l}=findPoint(o,e,"x");if(!(!l||a&&r))if(a)i.unshift(l);else{t.push(l);if(!r)break}}t.push(...i)}function findPoint(t,e,s){const i=t.interpolate(e,s);if(!i)return{};const n=i[s];const o=t.segments;const a=t.points;let r=false;let l=false;for(let t=0;t<o.length;t++){const e=o[t];const i=a[e.start][s];const c=a[e.end][s];if(kt(n,i,c)){r=n===i;l=n===c;break}}return{first:r,last:l,point:i}}class simpleArc{constructor(t){this.x=t.x;this.y=t.y;this.radius=t.radius}pathSegment(t,e,s){const{x:i,y:n,radius:o}=this;e=e||{start:0,end:b};t.arc(i,n,o,e.end,e.start,true);return!s.bounds}interpolate(t){const{x:e,y:s,radius:i}=this;const n=t.angle;return{x:e+Math.cos(n)*i,y:s+Math.sin(n)*i,angle:n}}}function _getTarget(t){const{chart:e,fill:s,line:i}=t;if(r(s))return getLineByIndex(e,s);if("stack"===s)return _buildStackLine(t);if("shape"===s)return true;const n=computeBoundary(t);return n instanceof simpleArc?n:_createBoundaryLine(n,i)}function getLineByIndex(t,e){const s=t.getDatasetMeta(e);const i=s&&t.isDatasetVisible(e);return i?s.dataset:null}function computeBoundary(t){const e=t.scale||{};return e.getPointPositionForValue?computeCircularBoundary(t):computeLinearBoundary(t)}function computeLinearBoundary(t){const{scale:e={},fill:s}=t;const i=_getTargetPixel(s,e);if(r(i)){const t=e.isHorizontal();return{x:t?i:null,y:t?null:i}}return null}function computeCircularBoundary(t){const{scale:e,fill:s}=t;const i=e.options;const n=e.getLabels().length;const o=i.reverse?e.max:e.min;const a=_getTargetValue(s,e,o);const r=[];if(i.grid.circular){const t=e.getPointPositionForValue(0,o);return new simpleArc({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(a)})}for(let t=0;t<n;++t)r.push(e.getPointPositionForValue(t,a));return r}function _drawfill(t,e,s){const i=_getTarget(e);const{line:n,scale:o,axis:a}=e;const r=n.options;const l=r.fill;const c=r.backgroundColor;const{above:h=c,below:d=c}=l||{};if(i&&n.points.length){U(t,s);doFill(t,{line:n,target:i,above:h,below:d,area:s,scale:o,axis:a});X(t)}}function doFill(t,e){const{line:s,target:i,above:n,below:o,area:a,scale:r}=e;const l=s._loop?"angle":e.axis;t.save();if("x"===l&&o!==n){clipVertical(t,i,a.top);fill(t,{line:s,target:i,color:n,scale:r,property:l});t.restore();t.save();clipVertical(t,i,a.bottom)}fill(t,{line:s,target:i,color:o,scale:r,property:l});t.restore()}function clipVertical(t,e,s){const{segments:i,points:n}=e;let o=true;let a=false;t.beginPath();for(const r of i){const{start:i,end:l}=r;const c=n[i];const h=n[_findSegmentEnd(i,l,n)];if(o){t.moveTo(c.x,c.y);o=false}else{t.lineTo(c.x,s);t.lineTo(c.x,c.y)}a=!!e.pathSegment(t,r,{move:a});a?t.closePath():t.lineTo(h.x,s)}t.lineTo(e.first().x,s);t.closePath();t.clip()}function fill(t,e){const{line:s,target:i,property:n,color:o,scale:a}=e;const r=_segments(s,i,n);for(const{source:e,target:l,start:c,end:h}of r){const{style:{backgroundColor:r=o}={}}=e;const d=true!==i;t.save();t.fillStyle=r;clipBounds(t,a,d&&_getBounds(n,c,h));t.beginPath();const u=!!s.pathSegment(t,e);let g;if(d){u?t.closePath():interpolatedLineTo(t,i,h,n);const e=!!i.pathSegment(t,l,{move:u,reverse:true});g=u&&e;g||interpolatedLineTo(t,i,c,n)}t.closePath();t.fill(g?"evenodd":"nonzero");t.restore()}}function clipBounds(t,e,s){const{top:i,bottom:n}=e.chart.chartArea;const{property:o,start:a,end:r}=s||{};if("x"===o){t.beginPath();t.rect(a,i,r-a,n-i);t.clip()}}function interpolatedLineTo(t,e,s,i){const n=e.interpolate(s,i);n&&t.lineTo(n.x,n.y)}var Ce={id:"filler",afterDatasetsUpdate(t,e,s){const i=(t.data.datasets||[]).length;const n=[];let o,a,r,l;for(a=0;a<i;++a){o=t.getDatasetMeta(a);r=o.dataset;l=null;r&&r.options&&r instanceof LineElement&&(l={visible:t.isDatasetVisible(a),index:a,fill:_decodeFill(r,a,i),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r});o.$filler=l;n.push(l)}for(a=0;a<i;++a){l=n[a];l&&false!==l.fill&&(l.fill=_resolveTarget(n,a,s.propagate))}},beforeDraw(t,e,s){const i="beforeDraw"===s.drawTime;const n=t.getSortedVisibleDatasetMetas();const o=t.chartArea;for(let e=n.length-1;e>=0;--e){const s=n[e].$filler;if(s){s.line.updateControlPoints(o,s.axis);i&&s.fill&&_drawfill(t.ctx,s,o)}}},beforeDatasetsDraw(t,e,s){if("beforeDatasetsDraw"!==s.drawTime)return;const i=t.getSortedVisibleDatasetMetas();for(let e=i.length-1;e>=0;--e){const s=i[e].$filler;_shouldApplyFill(s)&&_drawfill(t.ctx,s,t.chartArea)}},beforeDatasetDraw(t,e,s){const i=e.meta.$filler;_shouldApplyFill(i)&&"beforeDatasetDraw"===s.drawTime&&_drawfill(t.ctx,i,t.chartArea)},defaults:{propagate:true,drawTime:"beforeDatasetDraw"}};const getBoxSize=(t,e)=>{let{boxHeight:s=e,boxWidth:i=e}=t;if(t.usePointStyle){s=Math.min(s,e);i=t.pointStyleWidth||Math.min(i,e)}return{boxWidth:i,boxHeight:s,itemHeight:Math.max(e,s)}};const itemsEqual=(t,e)=>null!==t&&null!==e&&t.datasetIndex===e.datasetIndex&&t.index===e.index;class Legend extends Element{constructor(t){super();this._added=false;this.legendHitBoxes=[];this._hoveredItem=null;this.doughnutMode=false;this.chart=t.chart;this.options=t.options;this.ctx=t.ctx;this.legendItems=void 0;this.columnSizes=void 0;this.lineWidths=void 0;this.maxHeight=void 0;this.maxWidth=void 0;this.top=void 0;this.bottom=void 0;this.left=void 0;this.right=void 0;this.height=void 0;this.width=void 0;this._margins=void 0;this.position=void 0;this.weight=void 0;this.fullSize=void 0}update(t,e,s){this.maxWidth=t;this.maxHeight=e;this._margins=s;this.setDimensions();this.buildLabels();this.fit()}setDimensions(){if(this.isHorizontal()){this.width=this.maxWidth;this.left=this._margins.left;this.right=this.width}else{this.height=this.maxHeight;this.top=this._margins.top;this.bottom=this.height}}buildLabels(){const t=this.options.labels||{};let e=z(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data))));t.sort&&(e=e.sort(((e,s)=>t.sort(e,s,this.chart.data))));this.options.reverse&&e.reverse();this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display){this.width=this.height=0;return}const s=t.labels;const i=E(s.font);const n=i.size;const o=this._computeTitleHeight();const{boxWidth:a,itemHeight:r}=getBoxSize(s,n);let l,c;e.font=i.string;if(this.isHorizontal()){l=this.maxWidth;c=this._fitRows(o,n,a,r)+10}else{c=this.maxHeight;l=this._fitCols(o,n,a,r)+10}this.width=Math.min(l,t.maxWidth||this.maxWidth);this.height=Math.min(c,t.maxHeight||this.maxHeight)}_fitRows(t,e,s,i){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=this;const r=this.legendHitBoxes=[];const l=this.lineWidths=[0];const c=i+a;let h=t;n.textAlign="left";n.textBaseline="middle";let d=-1;let u=-c;this.legendItems.forEach(((t,g)=>{const f=s+e/2+n.measureText(t.text).width;if(0===g||l[l.length-1]+f+2*a>o){h+=c;l[l.length-(g>0?0:1)]=0;u+=c;d++}r[g]={left:0,top:u,row:d,width:f,height:i};l[l.length-1]+=f+a}));return h}_fitCols(t,e,s,i){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=this;const r=this.legendHitBoxes=[];const l=this.columnSizes=[];const c=o-t;let h=a;let d=0;let u=0;let g=0;let f=0;this.legendItems.forEach(((t,o)=>{const p=s+e/2+n.measureText(t.text).width;if(o>0&&u+i+2*a>c){h+=d+a;l.push({width:d,height:u});g+=d+a;f++;d=u=0}r[o]={left:g,top:u,col:f,width:p,height:i};d=Math.max(d,p);u+=i+a}));h+=d;l.push({width:d,height:u});return h}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight();const{legendHitBoxes:e,options:{align:s,labels:{padding:i},rtl:n}}=this;const o=Ft(n,this.left,this.width);if(this.isHorizontal()){let n=0;let a=B(s,this.left+i,this.right-this.lineWidths[n]);for(const r of e){if(n!==r.row){n=r.row;a=B(s,this.left+i,this.right-this.lineWidths[n])}r.top+=this.top+t+i;r.left=o.leftForLtr(o.x(a),r.width);a+=r.width+i}}else{let n=0;let a=B(s,this.top+t+i,this.bottom-this.columnSizes[n].height);for(const r of e){if(r.col!==n){n=r.col;a=B(s,this.top+t+i,this.bottom-this.columnSizes[n].height)}r.top=a;r.left+=this.left+i;r.left=o.leftForLtr(o.x(r.left),r.width);a+=r.height+i}}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const t=this.ctx;U(t,this);this._draw();X(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:s,ctx:i}=this;const{align:o,labels:a}=t;const r=n.color;const l=Ft(t.rtl,this.left,this.width);const c=E(a.font);const{color:d,padding:u}=a;const g=c.size;const f=g/2;let p;this.drawTitle();i.textAlign=l.textAlign("left");i.textBaseline="middle";i.lineWidth=.5;i.font=c.string;const{boxWidth:m,boxHeight:x,itemHeight:b}=getBoxSize(a,g);const drawLegendBox=function(t,e,s){if(isNaN(m)||m<=0||isNaN(x)||x<0)return;i.save();const n=h(s.lineWidth,1);i.fillStyle=h(s.fillStyle,r);i.lineCap=h(s.lineCap,"butt");i.lineDashOffset=h(s.lineDashOffset,0);i.lineJoin=h(s.lineJoin,"miter");i.lineWidth=n;i.strokeStyle=h(s.strokeStyle,r);i.setLineDash(h(s.lineDash,[]));if(a.usePointStyle){const o={radius:x*Math.SQRT2/2,pointStyle:s.pointStyle,rotation:s.rotation,borderWidth:n};const r=l.xPlus(t,m/2);const c=e+f;zt(i,o,r,c,a.pointStyleWidth&&m)}else{const o=e+Math.max((g-x)/2,0);const a=l.leftForLtr(t,m);const r=Et(s.borderRadius);i.beginPath();Object.values(r).some((t=>0!==t))?Rt(i,{x:a,y:o,w:m,h:x,radius:r}):i.rect(a,o,m,x);i.fill();0!==n&&i.stroke()}i.restore()};const fillText=function(t,e,s){Y(i,s.text,t,e+b/2,c,{strikethrough:s.hidden,textAlign:l.textAlign(s.textAlign)})};const _=this.isHorizontal();const y=this._computeTitleHeight();p=_?{x:B(o,this.left+u,this.right-s[0]),y:this.top+u+y,line:0}:{x:this.left+u,y:B(o,this.top+y+u,this.bottom-e[0].height),line:0};Vt(this.ctx,t.textDirection);const v=b+u;this.legendItems.forEach(((n,r)=>{i.strokeStyle=n.fontColor||d;i.fillStyle=n.fontColor||d;const c=i.measureText(n.text).width;const h=l.textAlign(n.textAlign||(n.textAlign=a.textAlign));const g=m+f+c;let x=p.x;let b=p.y;l.setWidth(this.width);if(_){if(r>0&&x+g+u>this.right){b=p.y+=v;p.line++;x=p.x=B(o,this.left+u,this.right-s[p.line])}}else if(r>0&&b+v>this.bottom){x=p.x=x+e[p.line].width+u;p.line++;b=p.y=B(o,this.top+y+u,this.bottom-e[p.line].height)}const k=l.x(x);drawLegendBox(k,b,n);x=Nt(h,x+m+f,_?x+g:this.right,t.rtl);fillText(l.x(x),b,n);_?p.x+=g+u:p.y+=v}));Wt(this.ctx,t.textDirection)}drawTitle(){const t=this.options;const e=t.title;const s=E(e.font);const i=R(e.padding);if(!e.display)return;const n=Ft(t.rtl,this.left,this.width);const o=this.ctx;const a=e.position;const r=s.size/2;const l=i.top+r;let c;let h=this.left;let d=this.width;if(this.isHorizontal()){d=Math.max(...this.lineWidths);c=this.top+l;h=B(t.align,h,this.right-d)}else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);c=l+B(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const u=B(a,h,h+d);o.textAlign=n.textAlign(I(a));o.textBaseline="middle";o.strokeStyle=e.color;o.fillStyle=e.color;o.font=s.string;Y(o,e.text,u,c,s)}_computeTitleHeight(){const t=this.options.title;const e=E(t.font);const s=R(t.padding);return t.display?e.lineHeight+s.height:0}_getLegendItemAt(t,e){let s,i,n;if(kt(t,this.left,this.right)&&kt(e,this.top,this.bottom)){n=this.legendHitBoxes;for(s=0;s<n.length;++s){i=n[s];if(kt(t,i.left,i.left+i.width)&&kt(e,i.top,i.top+i.height))return this.legendItems[s]}}return null}handleEvent(t){const e=this.options;if(!isListened(t.type,e))return;const s=this._getLegendItemAt(t.x,t.y);if("mousemove"===t.type||"mouseout"===t.type){const i=this._hoveredItem;const n=itemsEqual(i,s);i&&!n&&z(e.onLeave,[t,i,this],this);this._hoveredItem=s;s&&!n&&z(e.onHover,[t,s,this],this)}else s&&z(e.onClick,[t,s,this],this)}}function isListened(t,e){return!("mousemove"!==t&&"mouseout"!==t||!e.onHover&&!e.onLeave)||!(!e.onClick||"click"!==t&&"mouseup"!==t)}var De={id:"legend",_element:Legend,start(t,e,s){const i=t.legend=new Legend({ctx:t.ctx,options:s,chart:t});de.configure(t,i,s);de.addBox(t,i)},stop(t){de.removeBox(t,t.legend);delete t.legend},beforeUpdate(t,e,s){const i=t.legend;de.configure(t,i,s);i.options=s},afterUpdate(t){const e=t.legend;e.buildLabels();e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:true,position:"top",align:"center",fullSize:true,reverse:false,weight:1e3,onClick(t,e,s){const i=e.datasetIndex;const n=s.chart;if(n.isDatasetVisible(i)){n.hide(i);e.hidden=true}else{n.show(i);e.hidden=false}},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets;const{labels:{usePointStyle:s,pointStyle:i,textAlign:n,color:o}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const a=t.controller.getStyle(s?0:void 0);const r=R(a.borderWidth);return{text:e[t.index].label,fillStyle:a.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:(r.width+r.height)/4,strokeStyle:a.borderColor,pointStyle:i||a.pointStyle,rotation:a.rotation,textAlign:n||a.textAlign,borderRadius:0,datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:false,position:"center",text:""}},descriptors:{_scriptable:t=>!t.startsWith("on"),labels:{_scriptable:t=>!["generateLabels","filter","sort"].includes(t)}}};class Title extends Element{constructor(t){super();this.chart=t.chart;this.options=t.options;this.ctx=t.ctx;this._padding=void 0;this.top=void 0;this.bottom=void 0;this.left=void 0;this.right=void 0;this.width=void 0;this.height=void 0;this.position=void 0;this.weight=void 0;this.fullSize=void 0}update(t,e){const s=this.options;this.left=0;this.top=0;if(!s.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=t;this.height=this.bottom=e;const i=a(s.text)?s.text.length:1;this._padding=R(s.padding);const n=i*E(s.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=n:this.width=n}isHorizontal(){const t=this.options.position;return"top"===t||"bottom"===t}_drawArgs(t){const{top:e,left:s,bottom:i,right:n,options:o}=this;const a=o.align;let r=0;let l,c,h;if(this.isHorizontal()){c=B(a,s,n);h=e+t;l=n-s}else{if("left"===o.position){c=s+t;h=B(a,i,e);r=-.5*v}else{c=n-t;h=B(a,e,i);r=.5*v}l=i-e}return{titleX:c,titleY:h,maxWidth:l,rotation:r}}draw(){const t=this.ctx;const e=this.options;if(!e.display)return;const s=E(e.font);const i=s.lineHeight;const n=i/2+this._padding.top;const{titleX:o,titleY:a,maxWidth:r,rotation:l}=this._drawArgs(n);Y(t,e.text,0,0,s,{color:e.color,maxWidth:r,rotation:l,textAlign:I(e.align),textBaseline:"middle",translation:[o,a]})}}function createTitle(t,e){const s=new Title({ctx:t.ctx,options:e,chart:t});de.configure(t,s,e);de.addBox(t,s);t.titleBlock=s}var Pe={id:"title",_element:Title,start(t,e,s){createTitle(t,s)},stop(t){const e=t.titleBlock;de.removeBox(t,e);delete t.titleBlock},beforeUpdate(t,e,s){const i=t.titleBlock;de.configure(t,i,s);i.options=s},defaults:{align:"center",display:false,font:{weight:"bold"},fullSize:true,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:true,_indexable:false}};const Ae=new WeakMap;var Le={id:"subtitle",start(t,e,s){const i=new Title({ctx:t.ctx,options:s,chart:t});de.configure(t,i,s);de.addBox(t,i);Ae.set(t,i)},stop(t){de.removeBox(t,Ae.get(t));Ae.delete(t)},beforeUpdate(t,e,s){const i=Ae.get(t);de.configure(t,i,s);i.options=s},defaults:{align:"center",display:false,font:{weight:"normal"},fullSize:true,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:true,_indexable:false}};const Te={average(t){if(!t.length)return false;let e,s;let i=0;let n=0;let o=0;for(e=0,s=t.length;e<s;++e){const s=t[e].element;if(s&&s.hasValue()){const t=s.tooltipPosition();i+=t.x;n+=t.y;++o}}return{x:i/o,y:n/o}},nearest(t,e){if(!t.length)return false;let s=e.x;let i=e.y;let n=Number.POSITIVE_INFINITY;let o,a,r;for(o=0,a=t.length;o<a;++o){const s=t[o].element;if(s&&s.hasValue()){const t=s.getCenterPoint();const i=Ht(e,t);if(i<n){n=i;r=s}}}if(r){const t=r.tooltipPosition();s=t.x;i=t.y}return{x:s,y:i}}};function pushOrConcat(t,e){e&&(a(e)?Array.prototype.push.apply(t,e):t.push(e));return t}function splitNewlines(t){return("string"===typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function createTooltipItem(t,e){const{element:s,datasetIndex:i,index:n}=e;const o=t.getDatasetMeta(i).controller;const{label:a,value:r}=o.getLabelAndValue(n);return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[i].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:i,element:s}}function getTooltipSize(t,e){const s=t.chart.ctx;const{body:i,footer:n,title:o}=t;const{boxWidth:a,boxHeight:r}=e;const l=E(e.bodyFont);const c=E(e.titleFont);const h=E(e.footerFont);const d=o.length;const u=n.length;const g=i.length;const f=R(e.padding);let p=f.height;let m=0;let x=i.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);x+=t.beforeBody.length+t.afterBody.length;d&&(p+=d*c.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom);if(x){const t=e.displayColors?Math.max(r,l.lineHeight):l.lineHeight;p+=g*t+(x-g)*l.lineHeight+(x-1)*e.bodySpacing}u&&(p+=e.footerMarginTop+u*h.lineHeight+(u-1)*e.footerSpacing);let b=0;const maxLineWidth=function(t){m=Math.max(m,s.measureText(t).width+b)};s.save();s.font=c.string;O(t.title,maxLineWidth);s.font=l.string;O(t.beforeBody.concat(t.afterBody),maxLineWidth);b=e.displayColors?a+2+e.boxPadding:0;O(i,(t=>{O(t.before,maxLineWidth);O(t.lines,maxLineWidth);O(t.after,maxLineWidth)}));b=0;s.font=h.string;O(t.footer,maxLineWidth);s.restore();m+=f.width;return{width:m,height:p}}function determineYAlign(t,e){const{y:s,height:i}=e;return s<i/2?"top":s>t.height-i/2?"bottom":"center"}function doesNotFitWithAlign(t,e,s,i){const{x:n,width:o}=i;const a=s.caretSize+s.caretPadding;return"left"===t&&n+o+a>e.width||("right"===t&&n-o-a<0||void 0)}function determineXAlign(t,e,s,i){const{x:n,width:o}=s;const{width:a,chartArea:{left:r,right:l}}=t;let c="center";"center"===i?c=n<=(r+l)/2?"left":"right":n<=o/2?c="left":n>=a-o/2&&(c="right");doesNotFitWithAlign(c,t,e,s)&&(c="center");return c}function determineAlignment(t,e,s){const i=s.yAlign||e.yAlign||determineYAlign(t,s);return{xAlign:s.xAlign||e.xAlign||determineXAlign(t,e,s,i),yAlign:i}}function alignX(t,e){let{x:s,width:i}=t;"right"===e?s-=i:"center"===e&&(s-=i/2);return s}function alignY(t,e,s){let{y:i,height:n}=t;"top"===e?i+=s:i-="bottom"===e?n+s:n/2;return i}function getBackgroundPoint(t,e,s,i){const{caretSize:n,caretPadding:o,cornerRadius:a}=t;const{xAlign:r,yAlign:l}=s;const c=n+o;const{topLeft:h,topRight:d,bottomLeft:u,bottomRight:g}=Et(a);let f=alignX(e,r);const p=alignY(e,l,c);"center"===l?"left"===r?f+=c:"right"===r&&(f-=c):"left"===r?f-=Math.max(h,u)+n:"right"===r&&(f+=Math.max(d,g)+n);return{x:N(f,0,i.width-e.width),y:N(p,0,i.height-e.height)}}function getAlignedX(t,e,s){const i=R(s.padding);return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-i.right:t.x+i.left}function getBeforeAfterBodyLines(t){return pushOrConcat([],splitNewlines(t))}function createTooltipContext(t,e,s){return c(t,{tooltip:e,tooltipItems:s,type:"tooltip"})}function overrideCallbacks(t,e){const s=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return s?t.override(s):t}class Tooltip extends Element{constructor(t){super();this.opacity=0;this._active=[];this._eventPosition=void 0;this._size=void 0;this._cachedAnimations=void 0;this._tooltipItems=[];this.$animations=void 0;this.$context=void 0;this.chart=t.chart||t._chart;this._chart=this.chart;this.options=t.options;this.dataPoints=void 0;this.title=void 0;this.beforeBody=void 0;this.body=void 0;this.afterBody=void 0;this.footer=void 0;this.xAlign=void 0;this.yAlign=void 0;this.x=void 0;this.y=void 0;this.height=void 0;this.width=void 0;this.caretX=void 0;this.caretY=void 0;this.labelColors=void 0;this.labelPointStyles=void 0;this.labelTextColors=void 0}initialize(t){this.options=t;this._cachedAnimations=void 0;this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart;const s=this.options.setContext(this.getContext());const i=s.enabled&&e.options.animation&&s.animations;const n=new Animations(this.chart,i);i._cacheable&&(this._cachedAnimations=Object.freeze(n));return n}getContext(){return this.$context||(this.$context=createTooltipContext(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,e){const{callbacks:s}=e;const i=s.beforeTitle.apply(this,[t]);const n=s.title.apply(this,[t]);const o=s.afterTitle.apply(this,[t]);let a=[];a=pushOrConcat(a,splitNewlines(i));a=pushOrConcat(a,splitNewlines(n));a=pushOrConcat(a,splitNewlines(o));return a}getBeforeBody(t,e){return getBeforeAfterBodyLines(e.callbacks.beforeBody.apply(this,[t]))}getBody(t,e){const{callbacks:s}=e;const i=[];O(t,(t=>{const e={before:[],lines:[],after:[]};const n=overrideCallbacks(s,t);pushOrConcat(e.before,splitNewlines(n.beforeLabel.call(this,t)));pushOrConcat(e.lines,n.label.call(this,t));pushOrConcat(e.after,splitNewlines(n.afterLabel.call(this,t)));i.push(e)}));return i}getAfterBody(t,e){return getBeforeAfterBodyLines(e.callbacks.afterBody.apply(this,[t]))}getFooter(t,e){const{callbacks:s}=e;const i=s.beforeFooter.apply(this,[t]);const n=s.footer.apply(this,[t]);const o=s.afterFooter.apply(this,[t]);let a=[];a=pushOrConcat(a,splitNewlines(i));a=pushOrConcat(a,splitNewlines(n));a=pushOrConcat(a,splitNewlines(o));return a}_createItems(t){const e=this._active;const s=this.chart.data;const i=[];const n=[];const o=[];let a=[];let r,l;for(r=0,l=e.length;r<l;++r)a.push(createTooltipItem(this.chart,e[r]));t.filter&&(a=a.filter(((e,i,n)=>t.filter(e,i,n,s))));t.itemSort&&(a=a.sort(((e,i)=>t.itemSort(e,i,s))));O(a,(e=>{const s=overrideCallbacks(t.callbacks,e);i.push(s.labelColor.call(this,e));n.push(s.labelPointStyle.call(this,e));o.push(s.labelTextColor.call(this,e))}));this.labelColors=i;this.labelPointStyles=n;this.labelTextColors=o;this.dataPoints=a;return a}update(t,e){const s=this.options.setContext(this.getContext());const i=this._active;let n;let o=[];if(i.length){const t=Te[s.position].call(this,i,this._eventPosition);o=this._createItems(s);this.title=this.getTitle(o,s);this.beforeBody=this.getBeforeBody(o,s);this.body=this.getBody(o,s);this.afterBody=this.getAfterBody(o,s);this.footer=this.getFooter(o,s);const e=this._size=getTooltipSize(this,s);const a=Object.assign({},t,e);const r=determineAlignment(this.chart,s,a);const l=getBackgroundPoint(s,a,r,this.chart);this.xAlign=r.xAlign;this.yAlign=r.yAlign;n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(n={opacity:0});this._tooltipItems=o;this.$context=void 0;n&&this._resolveAnimations().update(this,n);t&&s.external&&s.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,s,i){const n=this.getCaretPosition(t,s,i);e.lineTo(n.x1,n.y1);e.lineTo(n.x2,n.y2);e.lineTo(n.x3,n.y3)}getCaretPosition(t,e,s){const{xAlign:i,yAlign:n}=this;const{caretSize:o,cornerRadius:a}=s;const{topLeft:r,topRight:l,bottomLeft:c,bottomRight:h}=Et(a);const{x:d,y:u}=t;const{width:g,height:f}=e;let p,m,x,b,_,y;if("center"===n){_=u+f/2;if("left"===i){p=d;m=p-o;b=_+o;y=_-o}else{p=d+g;m=p+o;b=_-o;y=_+o}x=p}else{m="left"===i?d+Math.max(r,c)+o:"right"===i?d+g-Math.max(l,h)-o:this.caretX;if("top"===n){b=u;_=b-o;p=m-o;x=m+o}else{b=u+f;_=b+o;p=m+o;x=m-o}y=b}return{x1:p,x2:m,x3:x,y1:b,y2:_,y3:y}}drawTitle(t,e,s){const i=this.title;const n=i.length;let o,a,r;if(n){const l=Ft(s.rtl,this.x,this.width);t.x=getAlignedX(this,s.titleAlign,s);e.textAlign=l.textAlign(s.titleAlign);e.textBaseline="middle";o=E(s.titleFont);a=s.titleSpacing;e.fillStyle=s.titleColor;e.font=o.string;for(r=0;r<n;++r){e.fillText(i[r],l.x(t.x),t.y+o.lineHeight/2);t.y+=o.lineHeight+a;r+1===n&&(t.y+=s.titleMarginBottom-a)}}}_drawColorBox(t,e,s,i,n){const a=this.labelColors[s];const r=this.labelPointStyles[s];const{boxHeight:l,boxWidth:c,boxPadding:h}=n;const d=E(n.bodyFont);const u=getAlignedX(this,"left",n);const g=i.x(u);const f=l<d.lineHeight?(d.lineHeight-l)/2:0;const p=e.y+f;if(n.usePointStyle){const e={radius:Math.min(c,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1};const s=i.leftForLtr(g,c)+c/2;const o=p+l/2;t.strokeStyle=n.multiKeyBackground;t.fillStyle=n.multiKeyBackground;Tt(t,e,s,o);t.strokeStyle=a.borderColor;t.fillStyle=a.backgroundColor;Tt(t,e,s,o)}else{t.lineWidth=o(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1;t.strokeStyle=a.borderColor;t.setLineDash(a.borderDash||[]);t.lineDashOffset=a.borderDashOffset||0;const e=i.leftForLtr(g,c-h);const s=i.leftForLtr(i.xPlus(g,1),c-h-2);const r=Et(a.borderRadius);if(Object.values(r).some((t=>0!==t))){t.beginPath();t.fillStyle=n.multiKeyBackground;Rt(t,{x:e,y:p,w:c,h:l,radius:r});t.fill();t.stroke();t.fillStyle=a.backgroundColor;t.beginPath();Rt(t,{x:s,y:p+1,w:c-2,h:l-2,radius:r});t.fill()}else{t.fillStyle=n.multiKeyBackground;t.fillRect(e,p,c,l);t.strokeRect(e,p,c,l);t.fillStyle=a.backgroundColor;t.fillRect(s,p+1,c-2,l-2)}}t.fillStyle=this.labelTextColors[s]}drawBody(t,e,s){const{body:i}=this;const{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:c}=s;const h=E(s.bodyFont);let d=h.lineHeight;let u=0;const g=Ft(s.rtl,this.x,this.width);const fillLineOfText=function(s){e.fillText(s,g.x(t.x+u),t.y+d/2);t.y+=d+n};const f=g.textAlign(o);let p,m,x,b,_,y,v;e.textAlign=o;e.textBaseline="middle";e.font=h.string;t.x=getAlignedX(this,f,s);e.fillStyle=s.bodyColor;O(this.beforeBody,fillLineOfText);u=a&&"right"!==f?"center"===o?l/2+c:l+2+c:0;for(b=0,y=i.length;b<y;++b){p=i[b];m=this.labelTextColors[b];e.fillStyle=m;O(p.before,fillLineOfText);x=p.lines;if(a&&x.length){this._drawColorBox(e,t,b,g,s);d=Math.max(h.lineHeight,r)}for(_=0,v=x.length;_<v;++_){fillLineOfText(x[_]);d=h.lineHeight}O(p.after,fillLineOfText)}u=0;d=h.lineHeight;O(this.afterBody,fillLineOfText);t.y-=n}drawFooter(t,e,s){const i=this.footer;const n=i.length;let o,a;if(n){const r=Ft(s.rtl,this.x,this.width);t.x=getAlignedX(this,s.footerAlign,s);t.y+=s.footerMarginTop;e.textAlign=r.textAlign(s.footerAlign);e.textBaseline="middle";o=E(s.footerFont);e.fillStyle=s.footerColor;e.font=o.string;for(a=0;a<n;++a){e.fillText(i[a],r.x(t.x),t.y+o.lineHeight/2);t.y+=o.lineHeight+s.footerSpacing}}}drawBackground(t,e,s,i){const{xAlign:n,yAlign:o}=this;const{x:a,y:r}=t;const{width:l,height:c}=s;const{topLeft:h,topRight:d,bottomLeft:u,bottomRight:g}=Et(i.cornerRadius);e.fillStyle=i.backgroundColor;e.strokeStyle=i.borderColor;e.lineWidth=i.borderWidth;e.beginPath();e.moveTo(a+h,r);"top"===o&&this.drawCaret(t,e,s,i);e.lineTo(a+l-d,r);e.quadraticCurveTo(a+l,r,a+l,r+d);"center"===o&&"right"===n&&this.drawCaret(t,e,s,i);e.lineTo(a+l,r+c-g);e.quadraticCurveTo(a+l,r+c,a+l-g,r+c);"bottom"===o&&this.drawCaret(t,e,s,i);e.lineTo(a+u,r+c);e.quadraticCurveTo(a,r+c,a,r+c-u);"center"===o&&"left"===n&&this.drawCaret(t,e,s,i);e.lineTo(a,r+h);e.quadraticCurveTo(a,r,a+h,r);e.closePath();e.fill();i.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart;const s=this.$animations;const i=s&&s.x;const n=s&&s.y;if(i||n){const s=Te[t.position].call(this,this._active,this._eventPosition);if(!s)return;const o=this._size=getTooltipSize(this,t);const a=Object.assign({},s,this._size);const r=determineAlignment(e,t,a);const l=getBackgroundPoint(t,a,r,e);if(i._to!==l.x||n._to!==l.y){this.xAlign=r.xAlign;this.yAlign=r.yAlign;this.width=o.width;this.height=o.height;this.caretX=s.x;this.caretY=s.y;this._resolveAnimations().update(this,l)}}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let s=this.opacity;if(!s)return;this._updateAnimationTarget(e);const i={width:this.width,height:this.height};const n={x:this.x,y:this.y};s=Math.abs(s)<.001?0:s;const o=R(e.padding);const a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;if(e.enabled&&a){t.save();t.globalAlpha=s;this.drawBackground(n,t,i,e);Vt(t,e.textDirection);n.y+=o.top;this.drawTitle(n,t,e);this.drawBody(n,t,e);this.drawFooter(n,t,e);Wt(t,e.textDirection);t.restore()}}getActiveElements(){return this._active||[]}setActiveElements(t,e){const s=this._active;const i=t.map((({datasetIndex:t,index:e})=>{const s=this.chart.getDatasetMeta(t);if(!s)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:s.data[e],index:e}}));const n=!_t(s,i);const o=this._positionChanged(i,e);if(n||o){this._active=i;this._eventPosition=e;this._ignoreReplayEvents=true;this.update(true)}}handleEvent(t,e,s=true){if(e&&this._ignoreReplayEvents)return false;this._ignoreReplayEvents=false;const i=this.options;const n=this._active||[];const o=this._getActiveElements(t,n,e,s);const a=this._positionChanged(o,t);const r=e||!_t(o,n)||a;if(r){this._active=o;if(i.enabled||i.external){this._eventPosition={x:t.x,y:t.y};this.update(true,e)}}return r}_getActiveElements(t,e,s,i){const n=this.options;if("mouseout"===t.type)return[];if(!i)return e;const o=this.chart.getElementsAtEventForMode(t,n.mode,n,s);n.reverse&&o.reverse();return o}_positionChanged(t,e){const{caretX:s,caretY:i,options:n}=this;const o=Te[n.position].call(this,t,e);return false!==o&&(s!==o.x||i!==o.y)}}Tooltip.positioners=Te;var Oe={id:"tooltip",_element:Tooltip,positioners:Te,afterInit(t,e,s){s&&(t.tooltip=new Tooltip({chart:t,options:s}))},beforeUpdate(t,e,s){t.tooltip&&t.tooltip.initialize(s)},reset(t,e,s){t.tooltip&&t.tooltip.initialize(s)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const s={tooltip:e};if(false===t.notifyPlugins("beforeTooltipDraw",s))return;e.draw(t.ctx);t.notifyPlugins("afterTooltipDraw",s)}},afterEvent(t,e){if(t.tooltip){const s=e.replay;t.tooltip.handleEvent(e.event,s,e.inChartArea)&&(e.changed=true)}},defaults:{enabled:true,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:true,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:{beforeTitle:jt,title(t){if(t.length>0){const e=t[0];const s=e.chart.data.labels;const i=s?s.length:0;if(this&&this.options&&"dataset"===this.options.mode)return e.dataset.label||"";if(e.label)return e.label;if(i>0&&e.dataIndex<i)return s[e.dataIndex]}return""},afterTitle:jt,beforeBody:jt,beforeLabel:jt,label(t){if(this&&this.options&&"dataset"===this.options.mode)return t.label+": "+t.formattedValue||t.formattedValue;let e=t.dataset.label||"";e&&(e+=": ");const s=t.formattedValue;x(s)||(e+=s);return e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex);const s=e.controller.getStyle(t.dataIndex);return{borderColor:s.borderColor,backgroundColor:s.backgroundColor,borderWidth:s.borderWidth,borderDash:s.borderDash,borderDashOffset:s.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex);const s=e.controller.getStyle(t.dataIndex);return{pointStyle:s.pointStyle,rotation:s.rotation}},afterLabel:jt,afterBody:jt,beforeFooter:jt,footer:jt,afterFooter:jt}},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:t=>"filter"!==t&&"itemSort"!==t&&"external"!==t,_indexable:false,callbacks:{_scriptable:false,_indexable:false},animation:{_fallback:false},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};var Ee=Object.freeze({__proto__:null,Decimation:we,Filler:Ce,Legend:De,SubTitle:Le,Title:Pe,Tooltip:Oe});const addIfString=(t,e,s,i)=>{if("string"===typeof e){s=t.push(e)-1;i.unshift({index:s,label:e})}else isNaN(e)&&(s=null);return s};function findOrAddLabel(t,e,s,i){const n=t.indexOf(e);if(-1===n)return addIfString(t,e,s,i);const o=t.lastIndexOf(e);return n!==o?s:n}const validIndex=(t,e)=>null===t?null:N(Math.round(t),0,e);class CategoryScale extends Scale{constructor(t){super(t);this._startValue=void 0;this._valueRange=0;this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:s,label:i}of e)t[s]===i&&t.splice(s,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(x(t))return null;const s=this.getLabels();e=isFinite(e)&&s[e]===t?e:findOrAddLabel(s,t,h(e,t),this._addedLabels);return validIndex(e,s.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:s,max:i}=this.getMinMax(true);if("ticks"===this.options.bounds){t||(s=0);e||(i=this.getLabels().length-1)}this.min=s;this.max=i}buildTicks(){const t=this.min;const e=this.max;const s=this.options.offset;const i=[];let n=this.getLabels();n=0===t&&e===n.length-1?n:n.slice(t,e+1);this._valueRange=Math.max(n.length-(s?0:1),1);this._startValue=this.min-(s?.5:0);for(let s=t;s<=e;s++)i.push({value:s});return i}getLabelForValue(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}configure(){super.configure();this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){"number"!==typeof t&&(t=this.parse(t));return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}CategoryScale.id="category";CategoryScale.defaults={ticks:{callback:CategoryScale.prototype.getLabelForValue}};function generateTicks$1(t,e){const s=[];const i=1e-14;const{bounds:n,step:o,min:a,max:r,precision:l,count:c,maxTicks:h,maxDigits:d,includeBounds:u}=t;const g=o||1;const f=h-1;const{min:p,max:m}=e;const b=!x(a);const _=!x(r);const y=!x(c);const v=(m-p)/(d+1);let k=$t((m-p)/f/g)*g;let M,S,w,C;if(k<i&&!b&&!_)return[{value:p},{value:m}];C=Math.ceil(m/k)-Math.floor(p/k);C>f&&(k=$t(C*k/f/g)*g);if(!x(l)){M=Math.pow(10,l);k=Math.ceil(k*M)/M}if("ticks"===n){S=Math.floor(p/k)*k;w=Math.ceil(m/k)*k}else{S=p;w=m}if(b&&_&&o&&Ut((r-a)/o,k/1e3)){C=Math.round(Math.min((r-a)/k,h));k=(r-a)/C;S=a;w=r}else if(y){S=b?a:S;w=_?r:w;C=c-1;k=(w-S)/C}else{C=(w-S)/k;C=Yt(C,Math.round(C),k/1e3)?Math.round(C):Math.ceil(C)}const D=Math.max(Xt(k),Xt(S));M=Math.pow(10,x(l)?D:l);S=Math.round(S*M)/M;w=Math.round(w*M)/M;let P=0;if(b)if(u&&S!==a){s.push({value:a});S<a&&P++;Yt(Math.round((S+P*k)*M)/M,a,relativeLabelSize(a,v,t))&&P++}else S<a&&P++;for(;P<C;++P)s.push({value:Math.round((S+P*k)*M)/M});_&&u&&w!==r?s.length&&Yt(s[s.length-1].value,r,relativeLabelSize(r,v,t))?s[s.length-1].value=r:s.push({value:r}):_&&w!==r||s.push({value:w});return s}function relativeLabelSize(t,e,{horizontal:s,minRotation:i}){const n=k(i);const o=(s?Math.sin(n):Math.cos(n))||.001;const a=.75*e*(""+t).length;return Math.min(e/o,a)}class LinearScaleBase extends Scale{constructor(t){super(t);this.start=void 0;this.end=void 0;this._startValue=void 0;this._endValue=void 0;this._valueRange=0}parse(t,e){return x(t)||("number"===typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options;const{minDefined:e,maxDefined:s}=this.getUserBounds();let{min:i,max:n}=this;const setMin=t=>i=e?i:t;const setMax=t=>n=s?n:t;if(t){const t=l(i);const e=l(n);t<0&&e<0?setMax(0):t>0&&e>0&&setMin(0)}if(i===n){let e=1;(n>=Number.MAX_SAFE_INTEGER||i<=Number.MIN_SAFE_INTEGER)&&(e=Math.abs(.05*n));setMax(n+e);t||setMin(i-e)}this.min=i;this.max=n}getTickLimit(){const t=this.options.ticks;let{maxTicksLimit:e,stepSize:s}=t;let i;if(s){i=Math.ceil(this.max/s)-Math.floor(this.min/s)+1;if(i>1e3){console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${i} ticks. Limiting to 1000.`);i=1e3}}else{i=this.computeTickLimit();e=e||11}e&&(i=Math.min(e,i));return i}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options;const e=t.ticks;let s=this.getTickLimit();s=Math.max(2,s);const i={maxTicks:s,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:false!==e.includeBounds};const n=this._range||this;const o=generateTicks$1(i,n);"ticks"===t.bounds&&Kt(o,this,"value");if(t.reverse){o.reverse();this.start=this.max;this.end=this.min}else{this.start=this.min;this.end=this.max}return o}configure(){const t=this.ticks;let e=this.min;let s=this.max;super.configure();if(this.options.offset&&t.length){const i=(s-e)/Math.max(t.length-1,1)/2;e-=i;s+=i}this._startValue=e;this._endValue=s;this._valueRange=s-e}getLabelForValue(t){return w(t,this.chart.options.locale,this.options.ticks.format)}}class LinearScale extends LinearScaleBase{determineDataLimits(){const{min:t,max:e}=this.getMinMax(true);this.min=r(t)?t:0;this.max=r(e)?e:1;this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal();const e=t?this.width:this.height;const s=k(this.options.ticks.minRotation);const i=(t?Math.sin(s):Math.cos(s))||.001;const n=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,n.lineHeight/i))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}LinearScale.id="linear";LinearScale.defaults={ticks:{callback:oe.formatters.numeric}};function isMajor(t){const e=t/Math.pow(10,Math.floor(L(t)));return 1===e}function generateTicks(t,e){const s=Math.floor(L(e.max));const i=Math.ceil(e.max/Math.pow(10,s));const n=[];let o=F(t.min,Math.pow(10,Math.floor(L(e.min))));let a=Math.floor(L(o));let r=Math.floor(o/Math.pow(10,a));let l=a<0?Math.pow(10,Math.abs(a)):1;do{n.push({value:o,major:isMajor(o)});++r;if(10===r){r=1;++a;l=a>=0?1:l}o=Math.round(r*Math.pow(10,a)*l)/l}while(a<s||a===s&&r<i);const c=F(t.max,o);n.push({value:c,major:isMajor(o)});return n}class LogarithmicScale extends Scale{constructor(t){super(t);this.start=void 0;this.end=void 0;this._startValue=void 0;this._valueRange=0}parse(t,e){const s=LinearScaleBase.prototype.parse.apply(this,[t,e]);if(0!==s)return r(s)&&s>0?s:null;this._zero=true}determineDataLimits(){const{min:t,max:e}=this.getMinMax(true);this.min=r(t)?Math.max(0,t):null;this.max=r(e)?Math.max(0,e):null;this.options.beginAtZero&&(this._zero=true);this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let s=this.min;let i=this.max;const setMin=e=>s=t?s:e;const setMax=t=>i=e?i:t;const exp=(t,e)=>Math.pow(10,Math.floor(L(t))+e);if(s===i)if(s<=0){setMin(1);setMax(10)}else{setMin(exp(s,-1));setMax(exp(i,1))}s<=0&&setMin(exp(i,-1));i<=0&&setMax(exp(s,1));this._zero&&this.min!==this._suggestedMin&&s===exp(this.min,0)&&setMin(exp(s,-1));this.min=s;this.max=i}buildTicks(){const t=this.options;const e={min:this._userMin,max:this._userMax};const s=generateTicks(e,this);"ticks"===t.bounds&&Kt(s,this,"value");if(t.reverse){s.reverse();this.start=this.max;this.end=this.min}else{this.start=this.min;this.end=this.max}return s}getLabelForValue(t){return void 0===t?"0":w(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure();this._startValue=L(t);this._valueRange=L(this.max)-L(t)}getPixelForValue(t){void 0!==t&&0!==t||(t=this.min);return null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(L(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}LogarithmicScale.id="logarithmic";LogarithmicScale.defaults={ticks:{callback:oe.formatters.logarithmic,major:{enabled:true}}};function getTickBackdropHeight(t){const e=t.ticks;if(e.display&&t.display){const t=R(e.backdropPadding);return h(e.font&&e.font.size,n.font.size)+t.height}return 0}function measureLabelSize(t,e,s){s=a(s)?s:[s];return{w:Gt(t,e.string,s),h:s.length*e.lineHeight}}function determineLimits(t,e,s,i,n){return t===i||t===n?{start:e-s/2,end:e+s/2}:t<i||t>n?{start:e-s,end:e}:{start:e,end:e+s}}function fitWithPointLabels(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom};const s=Object.assign({},e);const i=[];const n=[];const o=t._pointLabels.length;const a=t.options.pointLabels;const r=a.centerPointLabels?v/o:0;for(let l=0;l<o;l++){const o=a.setContext(t.getPointLabelContext(l));n[l]=o.padding;const c=t.getPointPosition(l,t.drawingArea+n[l],r);const h=E(o.font);const d=measureLabelSize(t.ctx,h,t._pointLabels[l]);i[l]=d;const u=Bt(t.getIndexAngle(l)+r);const g=Math.round(W(u));const f=determineLimits(g,c.x,d.w,0,180);const p=determineLimits(g,c.y,d.h,90,270);updateLimits(s,e,u,f,p)}t.setCenterPoint(e.l-s.l,s.r-e.r,e.t-s.t,s.b-e.b);t._pointLabelItems=buildPointLabelItems(t,i,n)}function updateLimits(t,e,s,i,n){const o=Math.abs(Math.sin(s));const a=Math.abs(Math.cos(s));let r=0;let l=0;if(i.start<e.l){r=(e.l-i.start)/o;t.l=Math.min(t.l,e.l-r)}else if(i.end>e.r){r=(i.end-e.r)/o;t.r=Math.max(t.r,e.r+r)}if(n.start<e.t){l=(e.t-n.start)/a;t.t=Math.min(t.t,e.t-l)}else if(n.end>e.b){l=(n.end-e.b)/a;t.b=Math.max(t.b,e.b+l)}}function buildPointLabelItems(t,e,s){const i=[];const n=t._pointLabels.length;const o=t.options;const a=getTickBackdropHeight(o)/2;const r=t.drawingArea;const l=o.pointLabels.centerPointLabels?v/n:0;for(let o=0;o<n;o++){const n=t.getPointPosition(o,r+a+s[o],l);const c=Math.round(W(Bt(n.angle+y)));const h=e[o];const d=yForAngle(n.y,h.h,c);const u=getTextAlignForAngle(c);const g=leftForTextAlign(n.x,h.w,u);i.push({x:n.x,y:d,textAlign:u,left:g,top:d,right:g+h.w,bottom:d+h.h})}return i}function getTextAlignForAngle(t){return 0===t||180===t?"center":t<180?"left":"right"}function leftForTextAlign(t,e,s){"right"===s?t-=e:"center"===s&&(t-=e/2);return t}function yForAngle(t,e,s){90===s||270===s?t-=e/2:(s>270||s<90)&&(t-=e);return t}function drawPointLabels(t,e){const{ctx:s,options:{pointLabels:i}}=t;for(let n=e-1;n>=0;n--){const e=i.setContext(t.getPointLabelContext(n));const o=E(e.font);const{x:a,y:r,textAlign:l,left:c,top:h,right:d,bottom:u}=t._pointLabelItems[n];const{backdropColor:g}=e;if(!x(g)){const t=Et(e.borderRadius);const i=R(e.backdropPadding);s.fillStyle=g;const n=c-i.left;const o=h-i.top;const a=d-c+i.width;const r=u-h+i.height;if(Object.values(t).some((t=>0!==t))){s.beginPath();Rt(s,{x:n,y:o,w:a,h:r,radius:t});s.fill()}else s.fillRect(n,o,a,r)}Y(s,t._pointLabels[n],a,r+o.lineHeight/2,o,{color:e.color,textAlign:l,textBaseline:"middle"})}}function pathRadiusLine(t,e,s,i){const{ctx:n}=t;if(s)n.arc(t.xCenter,t.yCenter,e,0,b);else{let s=t.getPointPosition(0,e);n.moveTo(s.x,s.y);for(let o=1;o<i;o++){s=t.getPointPosition(o,e);n.lineTo(s.x,s.y)}}}function drawRadiusLine(t,e,s,i){const n=t.ctx;const o=e.circular;const{color:a,lineWidth:r}=e;if((o||i)&&a&&r&&!(s<0)){n.save();n.strokeStyle=a;n.lineWidth=r;n.setLineDash(e.borderDash);n.lineDashOffset=e.borderDashOffset;n.beginPath();pathRadiusLine(t,s,o,i);n.closePath();n.stroke();n.restore()}}function createPointLabelContext(t,e,s){return c(t,{label:s,index:e,type:"pointLabel"})}class RadialLinearScale extends LinearScaleBase{constructor(t){super(t);this.xCenter=void 0;this.yCenter=void 0;this.drawingArea=void 0;this._pointLabels=[];this._pointLabelItems=[]}setDimensions(){const t=this._padding=R(getTickBackdropHeight(this.options)/2);const e=this.width=this.maxWidth-t.width;const s=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left);this.yCenter=Math.floor(this.top+s/2+t.top);this.drawingArea=Math.floor(Math.min(e,s)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(false);this.min=r(t)&&!isNaN(t)?t:0;this.max=r(e)&&!isNaN(e)?e:0;this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/getTickBackdropHeight(this.options))}generateTickLabels(t){LinearScaleBase.prototype.generateTickLabels.call(this,t);this._pointLabels=this.getLabels().map(((t,e)=>{const s=z(this.options.pointLabels.callback,[t,e],this);return s||0===s?s:""})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?fitWithPointLabels(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,s,i){this.xCenter+=Math.floor((t-e)/2);this.yCenter+=Math.floor((s-i)/2);this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,s,i))}getIndexAngle(t){const e=b/(this._pointLabels.length||1);const s=this.options.startAngle||0;return Bt(t*e+k(s))}getDistanceFromCenterForValue(t){if(x(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(x(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const s=e[t];return createPointLabelContext(this.getContext(),t,s)}}getPointPosition(t,e,s=0){const i=this.getIndexAngle(t)-y+s;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter,angle:i}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:s,right:i,bottom:n}=this._pointLabelItems[t];return{left:e,top:s,right:i,bottom:n}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const s=this.ctx;s.save();s.beginPath();pathRadiusLine(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length);s.closePath();s.fillStyle=t;s.fill();s.restore()}}drawGrid(){const t=this.ctx;const e=this.options;const{angleLines:s,grid:i}=e;const n=this._pointLabels.length;let o,a,r;e.pointLabels.display&&drawPointLabels(this,n);i.display&&this.ticks.forEach(((t,e)=>{if(0!==e){a=this.getDistanceFromCenterForValue(t.value);const s=i.setContext(this.getContext(e-1));drawRadiusLine(this,s,a,n)}}));if(s.display){t.save();for(o=n-1;o>=0;o--){const i=s.setContext(this.getPointLabelContext(o));const{color:n,lineWidth:l}=i;if(l&&n){t.lineWidth=l;t.strokeStyle=n;t.setLineDash(i.borderDash);t.lineDashOffset=i.borderDashOffset;a=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max);r=this.getPointPosition(o,a);t.beginPath();t.moveTo(this.xCenter,this.yCenter);t.lineTo(r.x,r.y);t.stroke()}}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx;const e=this.options;const s=e.ticks;if(!s.display)return;const i=this.getIndexAngle(0);let n,o;t.save();t.translate(this.xCenter,this.yCenter);t.rotate(i);t.textAlign="center";t.textBaseline="middle";this.ticks.forEach(((i,a)=>{if(0===a&&!e.reverse)return;const r=s.setContext(this.getContext(a));const l=E(r.font);n=this.getDistanceFromCenterForValue(this.ticks[a].value);if(r.showLabelBackdrop){t.font=l.string;o=t.measureText(i.label).width;t.fillStyle=r.backdropColor;const e=R(r.backdropPadding);t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}Y(t,i.label,0,-n,l,{color:r.color})}));t.restore()}drawTitle(){}}RadialLinearScale.id="radialLinear";RadialLinearScale.defaults={display:true,animate:true,position:"chartArea",angleLines:{display:true,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:false},startAngle:0,ticks:{showLabelBackdrop:true,callback:oe.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:true,font:{size:10},callback(t){return t},padding:5,centerPointLabels:false}};RadialLinearScale.defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};RadialLinearScale.descriptors={angleLines:{_fallback:"grid"}};const Re={millisecond:{common:true,size:1,steps:1e3},second:{common:true,size:1e3,steps:60},minute:{common:true,size:6e4,steps:60},hour:{common:true,size:36e5,steps:24},day:{common:true,size:864e5,steps:30},week:{common:false,size:6048e5,steps:4},month:{common:true,size:2628e6,steps:12},quarter:{common:false,size:7884e6,steps:4},year:{common:true,size:3154e7}};const Ie=Object.keys(Re);function sorter(t,e){return t-e}function parse(t,e){if(x(e))return null;const s=t._adapter;const{parser:i,round:n,isoWeekday:o}=t._parseOpts;let a=e;"function"===typeof i&&(a=i(a));r(a)||(a="string"===typeof i?s.parse(a,i):s.parse(a));if(null===a)return null;n&&(a="week"!==n||!P(o)&&true!==o?s.startOf(a,n):s.startOf(a,"isoWeek",o));return+a}function determineUnitForAutoTicks(t,e,s,i){const n=Ie.length;for(let o=Ie.indexOf(t);o<n-1;++o){const t=Re[Ie[o]];const n=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((s-e)/(n*t.size))<=i)return Ie[o]}return Ie[n-1]}function determineUnitForFormatting(t,e,s,i,n){for(let o=Ie.length-1;o>=Ie.indexOf(s);o--){const s=Ie[o];if(Re[s].common&&t._adapter.diff(n,i,s)>=e-1)return s}return Ie[s?Ie.indexOf(s):0]}function determineMajorUnit(t){for(let e=Ie.indexOf(t)+1,s=Ie.length;e<s;++e)if(Re[Ie[e]].common)return Ie[e]}function addTick(t,e,s){if(s){if(s.length){const{lo:i,hi:n}=qt(s,e);const o=s[i]>=e?s[i]:s[n];t[o]=true}}else t[e]=true}function setMajorTicks(t,e,s,i){const n=t._adapter;const o=+n.startOf(e[0].value,i);const a=e[e.length-1].value;let r,l;for(r=o;r<=a;r=+n.add(r,1,i)){l=s[r];l>=0&&(e[l].major=true)}return e}function ticksFromTimestamps(t,e,s){const i=[];const n={};const o=e.length;let a,r;for(a=0;a<o;++a){r=e[a];n[r]=a;i.push({value:r,major:false})}return 0!==o&&s?setMajorTicks(t,i,n,s):i}class TimeScale extends Scale{constructor(t){super(t);this._cache={data:[],labels:[],all:[]};this._unit="day";this._majorUnit=void 0;this._offsets={};this._normalized=false;this._parseOpts=void 0}init(t,e){const s=t.time||(t.time={});const i=this._adapter=new le._date(t.adapters.date);i.init(e);lt(s.displayFormats,i.formats());this._parseOpts={parser:s.parser,round:s.round,isoWeekday:s.isoWeekday};super.init(t);this._normalized=e.normalized}parse(t,e){return void 0===t?null:parse(this,t)}beforeLayout(){super.beforeLayout();this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options;const e=this._adapter;const s=t.time.unit||"day";let{min:i,max:n,minDefined:o,maxDefined:a}=this.getUserBounds();function _applyBounds(t){o||isNaN(t.min)||(i=Math.min(i,t.min));a||isNaN(t.max)||(n=Math.max(n,t.max))}if(!o||!a){_applyBounds(this._getLabelBounds());"ticks"===t.bounds&&"labels"===t.ticks.source||_applyBounds(this.getMinMax(false))}i=r(i)&&!isNaN(i)?i:+e.startOf(Date.now(),s);n=r(n)&&!isNaN(n)?n:+e.endOf(Date.now(),s)+1;this.min=Math.min(i,n-1);this.max=Math.max(i+1,n)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY;let s=Number.NEGATIVE_INFINITY;if(t.length){e=t[0];s=t[t.length-1]}return{min:e,max:s}}buildTicks(){const t=this.options;const e=t.time;const s=t.ticks;const i="labels"===s.source?this.getLabelTimestamps():this._generate();if("ticks"===t.bounds&&i.length){this.min=this._userMin||i[0];this.max=this._userMax||i[i.length-1]}const n=this.min;const o=this.max;const a=Jt(i,n,o);this._unit=e.unit||(s.autoSkip?determineUnitForAutoTicks(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):determineUnitForFormatting(this,a.length,e.minUnit,this.min,this.max));this._majorUnit=s.major.enabled&&"year"!==this._unit?determineMajorUnit(this._unit):void 0;this.initOffsets(i);t.reverse&&a.reverse();return ticksFromTimestamps(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t){let e=0;let s=0;let i,n;if(this.options.offset&&t.length){i=this.getDecimalForValue(t[0]);e=1===t.length?1-i:(this.getDecimalForValue(t[1])-i)/2;n=this.getDecimalForValue(t[t.length-1]);s=1===t.length?n:(n-this.getDecimalForValue(t[t.length-2]))/2}const o=t.length<3?.5:.25;e=N(e,0,o);s=N(s,0,o);this._offsets={start:e,end:s,factor:1/(e+1+s)}}_generate(){const t=this._adapter;const e=this.min;const s=this.max;const i=this.options;const n=i.time;const o=n.unit||determineUnitForAutoTicks(n.minUnit,e,s,this._getLabelCapacity(e));const a=h(n.stepSize,1);const r="week"===o&&n.isoWeekday;const l=P(r)||true===r;const c={};let d=e;let u,g;l&&(d=+t.startOf(d,"isoWeek",r));d=+t.startOf(d,l?"day":o);if(t.diff(s,e,o)>1e5*a)throw new Error(e+" and "+s+" are too far apart with stepSize of "+a+" "+o);const f="data"===i.ticks.source&&this.getDataTimestamps();for(u=d,g=0;u<s;u=+t.add(u,a,o),g++)addTick(c,u,f);u!==s&&"ticks"!==i.bounds&&1!==g||addTick(c,u,f);return Object.keys(c).sort(((t,e)=>t-e)).map((t=>+t))}getLabelForValue(t){const e=this._adapter;const s=this.options.time;return s.tooltipFormat?e.format(t,s.tooltipFormat):e.format(t,s.displayFormats.datetime)}_tickFormatFunction(t,e,s,i){const n=this.options;const o=n.time.displayFormats;const a=this._unit;const r=this._majorUnit;const l=a&&o[a];const c=r&&o[r];const h=s[e];const d=r&&c&&h&&h.major;const u=this._adapter.format(t,i||(d?c:l));const g=n.ticks.callback;return g?z(g,[u,e,s],this):u}generateTickLabels(t){let e,s,i;for(e=0,s=t.length;e<s;++e){i=t[e];i.label=this._tickFormatFunction(i.value,e,t)}}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets;const s=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+s)*e.factor)}getValueForPixel(t){const e=this._offsets;const s=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+s*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks;const s=this.ctx.measureText(t).width;const i=k(this.isHorizontal()?e.maxRotation:e.minRotation);const n=Math.cos(i);const o=Math.sin(i);const a=this._resolveTickFontOptions(0).size;return{w:s*n+a*o,h:s*o+a*n}}_getLabelCapacity(t){const e=this.options.time;const s=e.displayFormats;const i=s[e.unit]||s.millisecond;const n=this._tickFormatFunction(t,0,ticksFromTimestamps(this,[t],this._majorUnit),i);const o=this._getLabelSize(n);const a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t=this._cache.data||[];let e,s;if(t.length)return t;const i=this.getMatchingVisibleMetas();if(this._normalized&&i.length)return this._cache.data=i[0].controller.getAllParsedValues(this);for(e=0,s=i.length;e<s;++e)t=t.concat(i[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){const t=this._cache.labels||[];let e,s;if(t.length)return t;const i=this.getLabels();for(e=0,s=i.length;e<s;++e)t.push(parse(this,i[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return m(t.sort(sorter))}}TimeScale.id="time";TimeScale.defaults={bounds:"data",adapters:{},time:{parser:false,unit:false,round:false,isoWeekday:false,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",major:{enabled:false}}};function interpolate(t,e,s){let i=0;let n=t.length-1;let o,a,r,l;if(s){e>=t[i].pos&&e<=t[n].pos&&({lo:i,hi:n}=Z(t,"pos",e));({pos:o,time:r}=t[i]);({pos:a,time:l}=t[n])}else{e>=t[i].time&&e<=t[n].time&&({lo:i,hi:n}=Z(t,"time",e));({time:o,pos:r}=t[i]);({time:a,pos:l}=t[n])}const c=a-o;return c?r+(l-r)*(e-o)/c:r}class TimeSeriesScale extends TimeScale{constructor(t){super(t);this._table=[];this._minPos=void 0;this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable();const e=this._table=this.buildLookupTable(t);this._minPos=interpolate(e,this.min);this._tableRange=interpolate(e,this.max)-this._minPos;super.initOffsets(t)}buildLookupTable(t){const{min:e,max:s}=this;const i=[];const n=[];let o,a,r,l,c;for(o=0,a=t.length;o<a;++o){l=t[o];l>=e&&l<=s&&i.push(l)}if(i.length<2)return[{time:e,pos:0},{time:s,pos:1}];for(o=0,a=i.length;o<a;++o){c=i[o+1];r=i[o-1];l=i[o];Math.round((c+r)/2)!==l&&n.push({time:l,pos:o/(a-1)})}return n}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps();const s=this.getLabelTimestamps();t=e.length&&s.length?this.normalize(e.concat(s)):e.length?e:s;t=this._cache.all=t;return t}getDecimalForValue(t){return(interpolate(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets;const s=this.getDecimalForPixel(t)/e.factor-e.end;return interpolate(this._table,s*this._tableRange+this._minPos,true)}}TimeSeriesScale.id="timeseries";TimeSeriesScale.defaults=TimeScale.defaults;var Be=Object.freeze({__proto__:null,CategoryScale:CategoryScale,LinearScale:LinearScale,LogarithmicScale:LogarithmicScale,RadialLinearScale:RadialLinearScale,TimeScale:TimeScale,TimeSeriesScale:TimeSeriesScale});const Fe=[re,Se,Ee,Be];export{Animation,Animations,ArcElement,BarController,BarElement,BasePlatform,BasicPlatform,BubbleController,CategoryScale,Chart,DatasetController,we as Decimation,DomPlatform,DoughnutController,Element,Ce as Filler,ce as Interaction,De as Legend,LineController,LineElement,LinearScale,LogarithmicScale,PieController,PointElement,PolarAreaController,RadarController,RadialLinearScale,Scale,ScatterController,Le as SubTitle,oe as Ticks,TimeScale,TimeSeriesScale,Pe as Title,Oe as Tooltip,le as _adapters,_detectPlatform,Zt as animator,re as controllers,Se as elements,de as layouts,Ee as plugins,Fe as registerables,ae as registry,Be as scales};

